// KÜTÜPHANELER güncel
// Genel
#include <Arduino.h>
// Modbus
#include "BASS_ModbusMaster.h"
#include "BASS_ModbusRTUSlave.h"
// Dahili
#include "Wire.h"
#include "SPI.h"
#include "EEPROM.h"
// Komponent
#include "MCP4725.h"
// Ekran
#include "TFT_eSPI.h"
#include "Free_Fonts.h"  // Include the header file attached to this sketch
// Wi-Fi
#include <WiFi.h>
#include <HTTPClient.h>
#include <Update.h>
// Görseller
#include "bass_logo_kucuk.h"
#include "better_solution.h"
#include "basic_settings_icon.h"
#include "advanced_setting_icon.h"
#include "output_icon.h"
#include "communication_icon.h"
#include "display_icon.h"
#include "data_logging_icon.h"
#include "Information_icon.h"
#include "locckk.h"

// ADRESLER
#define MPC_DAC_ADDRESS 0x60  // I²C cihaz adresi

// PİN ATAMALARI
// Modbus Direction Pinleri
#define DE_RE_PIN_1 -1
#define DE_RE_PIN_2 -1
// Butonlar
// ekran düz butonlar düz
// #define esc_button 12    // user button 1
// #define up_button 25     // user button 3
// #define down_button 19   // user button 4
// #define enter_button 13  // user button 2
// polonya ürünü ekran ters butonlar farklı
#define esc_button 3    
#define enter_button 20 
#define up_button 5      
#define down_button 7  
// ekran ters butonlar düz
// #define esc_button 19    // user button 1
// #define up_button 13     // user button 3
// #define down_button 12   // user button 4
// #define enter_button 25  // user button 2
// Dijital Çıkışlar
#define relay_pin 15   // röle
#define pulse_pin 16  // pulse
// Analog çıkışlar
// #define DAC_2_PIN_V 26 - I2C olmuş düzeltilecek
// Analog Girişler
#define NTC_PIN 6
// Uart pinleri (serial)
#define SLAVE_RX_PIN 44
#define SLAVE_TX_PIN 43
// Uart pinleri (serial2)
#define MASTER_RX_PIN 18
#define MASTER_TX_PIN 17
// Ekran backlight
#define LCD_BLK 10

// Renk tanımlamarı
#define TFT_GREY 0x94b2
#define TFT_SHADOW 0xb5b6
#define TFT_CREAM 0xef15
#define TFT_BLUEE 0x2439
#define TFT_GRAYY 0xef7d

// TFT KÜTÜPHANESİ GÜNCELLENİNCE BU PİNLER EKLENECEK
// #define TFT_MOSI 23 // In some display driver board, it might be written as "SDA" and so on.
// #define TFT_SCLK 18
// #define TFT_CS   15  // Chip select control pin
// #define TFT_DC   2  // Data Command control pin
// #define TFT_RST  4  // Reset pin (could connect to Arduino RESET pin)

// SABİTLER
enum Languages {
  English,
  Turkish,
};

enum Eeprom_addresses {
  slave_ID_eep_address = 0,                     // (1 byte)
  eeprom_write_status_address = 1,              // eepromdan okunacak verilerin doğruluğu için ilk yazma gerçekleşti mi kontrol register adresi (1 byte)
  main_password_address = 2,                    // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  modbus_baud_rate_address = 4,                 // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  modbus_parity_bit_address = 6,                // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  previous_flow_rate_adress = 8,                //bu adres 4 byte veri depoladığından dolayı sonraki adres +4 ileri olacaktır (2 byte)
  modbus_stop_bit_address = 12,                 // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  theme_color_address = 14,                     // bu adres 1 byte veri depoladığından dolayı sonraki adres +1 ileri olacaktır (1 byte)
  analog_out_2_type_address = 15,               // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  analog_out_3_type_address = 17,               // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  upper_limit_VDC_address = 19,                 // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  lower_limit_VDC_address = 21,                 // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  upper_limit_mA_address = 23,                  // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  lower_limit_mA_address = 25,                  // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  D_out_2_alarm_state_address = 27,             // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  D_out_3_alarm_state_address = 29,             // bu adres 2 byte veri depoladığından dolayı sonraki adres +2 ileri olacaktır (2 byte)
  conductivity_k_factor_register_address = 31,  // bu adres 4 byte veri depoladığından dolayı sonraki adres +4 ileri olacaktır (2 byte)
  screen_refresh_time_value_address = 35,       // bu adres 4 byte veri depoladığından dolayı sonraki adres +4 ileri olacaktır (2 byte)
  total_eeprom_positive_address = 39,           // bu adres 4 byte veri depoladığından dolayı sonraki adres +4 ileri olacaktır (2 byte)
  total_eeprom_negative_address = 43,           // bu adres 4 byte veri depoladığından dolayı sonraki adres +4 ileri olacaktır (2 byte)
  screen_total_choice_address = 47, // bu adres 1 byte veri depoladığından dolayı sonraki adres +1 ileri olacaktır (2 byte)

};

enum button_definitions {
  press_esc = 1,
  press_up,
  press_down,
  press_enter,
};

enum labels {
  // Main and differantial screens
  main_screen = 1,

  // Password screen
  password_screen,

  // SETTINGS
  settings,
  basic_settings,
  advanced_settings,
  output,
  communication,
  display,
  data_logging,
  information,

  // BASIC SETTINGS
  quick_setup,
  languages,
  flow_parameters,
  sensor_size,

  // BASIC SETTINGS - Language
  english_language,
  turkish_language,

  // BASIC SETTINGS - Quick setup
  _sensor_size,
  _flow_range,
  _k_factor,
  _pulse_factor,

  // BASIC SETTINGS - Flow parameters
  _units,
  flow_range,
  flow_cut_off,
  flow_direction,

  // BASIC SETTINGS - Flow parameters - Units
  flow_unit,
  total_unit,

  // BASIC SETTINGS - Flow parameters - Flow unit
  m3_h,
  L_h,

  // BASIC SETTINGS - Flow parameters - Total unit
  m3_,
  L_,

  // BASIC SETTINGS - Flow parameters - Flow direction
  forward,
  reverse,

  // BASIC SETTINGS - Sensor size
  size_32,
  size_40,
  size_45,
  size_50,
  size_55,
  size_65,
  size_70,
  size_75,
  size_80,
  size_85,
  size_90,
  size_95,
  size_100,
  size_125,
  size_150,
  size_200,
  size_250,
  size_300,
  size_320,
  size_350,
  size_400,
  size_450,
  size_500,
  size_550,
  size_600,
  size_650,
  size_700,
  size_750,
  size_800,
  size_850,
  size_900,
  size_950,
  size_1000,
  size_1100,
  size_1200,
  size_1300,
  size_1400,
  size_1500,
  size_1600,
  size_1700,
  size_1800,
  size_1900,
  size_2000,
  size_2100,
  size_2200,
  size_2300,
  size_2400,
  size_2500,
  size_2600,
  size_2700,
  size_2800,
  size_2900,
  size_3000,
  size_4000,

  // ADVENCED SETTINGS
  k_factor,
  meter_factor,
  reset,
  change_password,

  // ADVENCED SETTINGS - Fine calibration
  sensitivity,
  application_mode,
  sensor_freqency,
  fine_calibration_en,
  _1_st_point,
  _1_st_value,
  _2_st_point,
  _2_st_value,
  _3_st_point,
  _3_st_value,
  _4_st_point,
  _4_st_value,

  // ADVENCED SETTINGS - Application mode
  normal,
  pulp_or_slurry,

  // ADVENCED SETTINGS - Sensor freqency
  _5_Hz,
  _4_167_Hz,
  _3_125_Hz,

  // ADVENCED SETTINGS - Fine calibration EN
  enable,
  disable,

  // ADVENCED SETTINGS - Density - Density unit
  g_cm3,
  kg_m3,
  Lb_ukgal,
  Lb_usgal,
  Lb_f3,

  // ADVENCED SETTINGS - Reset
  total_forward_reset,
  total_reverse_reset,

  // ADVENCED SETTINGS - Zero function
  automatic_zero,
  manual_zero,

  // ADVENCED SETTINGS - Factory reset
  no,
  yes,

  // OUTPUT
  analog_output,
  digital_output,
  alarms,

  // OUTPUT - Analog output
  analog_out_1_mA,
  analog_out_3_VDC,

  // OUTPUT - Analog output - Analog output 1 mA
  function_analog_out_1_mA,
  output_type_analog_out_1_mA,
  test_mode_analog_out_1_mA,
  output_calibration_analog_out_1_mA,

  // OUTPUT - Analog output - Analog output 2 mA
  function_analog_out_2_mA,
  output_type_analog_out_2_mA,
  test_mode_analog_out_2_mA,
  output_calibration_analog_out_2_mA,

  // OUTPUT - Analog output - Analog output 3 VDC
  function_analog_out_3_VDC,
  output_type_analog_out_3_VDC,
  test_mode_analog_out_3_VDC,
  output_calibration_analog_out_3_VDC,

  // OUTPUT - Analog output - Analog output 1
  ma_4_20,
  ma_4_12_20,
  ma_0_20,

  // OUTPUT - Analog output - Analog output 2 - Function
  flow_type,
  temperature_type,
  conductivity_type,

  // OUTPUT - Analog output - Analog output 2 - Output types
  _ma_4_20,
  _ma_4_12_20,

  // OUTPUT - Analog output - Analog output 3 - Output types
  v_0_10,
  v_0_5_10,

  // OUTPUT - Analog output - Analog output 1 mA - Test mode
  ma_4,
  ma_12,
  ma_20,

  // OUTPUT - Analog output - Analog output 2 mA - Test mode
  ma_4_analog_out_2_mA,
  ma_12_analog_out_2_mA,
  ma_20_analog_out_2_mA,

  // OUTPUT - Analog output - Analog output 3 VDC - Test mode
  v_5_analog_out_3_VDC,
  v_10_analog_out_3_VDC,

  // OUTPUT - Analog output - Analog output 1 - Output calibration
  set_lower_analog_out_1_mA,
  set_upper_analog_out_1_mA,

  // OUTPUT - Analog output - Analog output 2 - Output calibration
  set_lower_analog_out_2_mA,
  set_upper_analog_out_2_mA,

  // OUTPUT - Analog output - Analog output 3 - Output calibration
  set_lower_analog_out_3_VDC,
  set_upper_analog_out_3_VDC,

  // OUTPUT - Digital output
  digital_out_1,
  digital_out_2,
  digital_out_3,

  // OUTPUT - Digital output - Digital out 1
  out_functions,
  pulse_settings,

  // OUTPUT - Digital output - Out functions
  high_alarm_out_fnc,
  low_alarm_out_fnc,

  // OUTPUT - Digital output - Pulse settings
  pulse_factor,
  pulse_width,
  output_type,
  max_frequency,
  min_frequency,

  // OUTPUT - Digital output - Digital out 1
  pulse_frequency,
  high_flow_alarm,
  low_flow_alarm,
  conductivity,
  system_alarm,
  direction,

  // OUTPUT - Digital output - Output type
  frequency,
  pulse,

  // OUTPUT - Alarm
  alarm_output,
  high_alarm,
  low_alarm,
  sys_alarm,

  // OUTPUT - Alarm - Alarm output
  high_flow,
  low_flow,
  empty_pipe,
  reverse_direction,
  system_,
  disable_alarm,

  // COMMUNICATION
  modbus_,
  ethernet,
  hart,
  profibus,
  bluetooth,
  wifi,

  // COMMUNICATION - Modbus
  modbus_baudrate,
  modbus_id,
  modbus_parity_bit,
  modbus_stop_bit,

  // COMMUNICATION - Modbus - Baudrate
  baud_1200,
  baud_2400,
  baud_4800,
  baud_9600,
  baud_19200,
  baud_38400,

  // COMMUNICATION - Modbus - Parity bit
  none,
  odd,
  even,

  // COMMUNICATION - Modbus - Stop bit
  one,
  two,

  // COMMUNICATION - Wifi - Wifi firmware uptade
  wifi_firmware_uptade,

  // DISPLAY
  reverse_colors,
  screen_refresh_time,
  damping_time,

  // DISPLAY - Reverse colors
  dark_theme,
  white_theme,

  // DISPLAY - Damping time
  second_1,
  second_2,
  second_4,
  second_6,
  second_8,
  second_10,
  second_16,
  second_30,
  second_40,
  second_60,

  // DATA LOGGING
  interval_unit,
  interval_time,

  // INFORMATION
  serial_no,
  product_date,
  _information,
};

// Diller
char *english[] = {
  "Password",                     // 0
  "Please enter password",        // 1
  "done !",                       // 2
  "Wrong password ! Try again",   // 3
  "Basic Settings",               // 4
  "Advanced Settings",            // 5
  "Output",                       // 6
  "Communication",                // 7
  "Display",                      // 8
  "Data Logging",                 // 9
  "Information",                  // 10
  "MENU",                         // 11
  "MSG :",                        // 12
  "P",                            // 13
  "PF EMDE V2.0",                 // 14
  "Language",                     // 15
  "Flow Parameters",              // 16
  "Sensor Size",                  // 17
  "Zero Functions",               // 18
  "Density - Conductivity",       // 19
  "Change Password",              // 20
  "Reset",                        // 21
  "Fine Calibration",             // 22
  "Meter - K Factor",             // 23
  "Analog Output",                // 24
  "Digital Output",               // 25
  "Theme Selection",              // 26
  "Line 1",                       // 27
  "Line 2",                       // 28
  "Serial No",                    // 29
  "Product Date",                 // 30
  "Information",                  // 31
  "Flow Unit",                    // 32
  "Flow Range",                   // 33
  "Decimal Point",                // 34
  "Response Time",                // 35
  "Flow Cut-Off",                 // 36
  "Flow Direction",               // 37
  "Interval Unit",                // 38
  "Interval Time",                // 39
  "Modbus",                       // 40
  "Ethernet            [NA]",     // 41
  "Hart                  [NA]",   // 42
  "Profibus            [NA]",     // 43
  "Bluetooth          [NA]",      // 44
  "Wi-Fi",                        // 45
  "[NA]",                         // 46
  "Functions",                    // 47
  "Automatic Zero",               // 48
  "Manual Zero",                  // 49
  "Modbus Baudrate",              // 50
  "Modbus ID",                    // 51
  "Modbus Parity Bit",            // 52
  "0 - 10 V",                     // 53
  "4 - 20 mA",                    // 54
  "Digital Out 1",                // 55
  "Digital Out 2",                // 56
  "Digital Out 3",                // 57
  "0 - 10 mA",                    // 58
  "0 - 20 mA",                    // 59
  "4 - 12 - 20 mA",               // 60
  "Pulse - Frequency",            // 61
  "High Flow Alarm",              // 62
  "Low Flow Alarm",               // 63
  "Conductivity",                 // 64
  "System Alarm",                 // 65
  "Direction",                    // 66
  "Pulse",                        // 67
  "Frequency",                    // 68
  "Range",                        // 69
  "None",                         // 70
  "Odd",                          // 71
  "Even",                         // 72
  "out of range",                 // 73
  "Density Unit",                 // 74
  "Density Value",                // 75
  "active",                       // 76
  "passive",                      // 77
  "English",                      // 78
  "Turkish",                      // 79
  "Forward",                      // 80
  "Reverse",                      // 81
  "Analog Out 1  mA",             // 82
  "Analog Out 1  mA",             // 83
  "Output Type",                  // 84
  "Flow",                         // 85
  "Temperature",                  // 86
  "Conductivity",                 // 87
  "only for flowrate",            // 88
  "Forward - Reverse",            // 89
  "YES",                          // 90
  "NO",                           // 91
  "Please enter valid password",  // 92
  "Please enter new password",    // 93
  "The password was changed",     // 94
  "Factory Reset",                // 95
  "Forward Total Reset",          // 96
  "Reverse Total Reset",         // 97
  "Modbus Stop Bit",              // 98
  "Dark Theme",                   // 99
  "White Theme",                  // 100
  "Analog Out 2  VDC",            // 101
  "Test Mode",                    // 102
  "Output Calibration",           // 103
  "Adjust 4 mA",                  // 104
  "Adjust 20 mA",                 // 105
  "Adjust 0 V",                   // 106
  "Adjust 10 V",                  // 107
  "K Factor",                     // 108
  "Units",                        // 109
  "Total Unit",                   // 110
  "Sensitivity",                  // 111
  "Meter Factor",                 // 112
  "Conductivity",                 // 113
  "Density",                      // 114
  "Application Mode",             // 115
  "Sensor Frequency",             // 116
  "1st point",                    // 117
  "1st value",                    // 118
  "2nd point",                    // 119
  "2nd value",                    // 120
  "3rd point",                    // 121
  "3rd value",                    // 122
  "4th point",                    // 123
  "4th value",                    // 124
  "Fine Calibration EN.",         // 125
  "Normal",                       // 126
  "Pulp or Slurry",               // 127
  "Enable",                       // 128
  "Disable",                      // 129
  "Alarm",                        // 130
  "Alarm EN.",                    // 131
  "Alarm Option",                 // 132
  "Alarm Mode",                   // 133
  "Alarm Value",                  // 134
  "Alarm Iout",                   // 135
  "High Flow Alarm",                   // 136
  "Low Flow Alarm",                    // 137
  "System Alarm EN.",             // 138
  "Q [%]",                        // 139
  "Q [unit]",                     // 140
  "Total Net",                    // 141
  "Total Forward",                // 142
  "Total Reverse",                // 143
  "Active High",                  // 144
  "Active Low",                   // 145
  "High Alarm Out Fnc.",          // 146
  "Low Alarm Out Fnc.",           // 147
  "Pulse Factor",                 // 148
  "Pulse Width",                  // 149
  "Max Frequency",                // 150
  "Pulse Test",                   // 151
  "Out Functions",                // 152
  "Pulse Settings",               // 153
  "Quick Setup",                  // 154
  "Conductivity Alarm Value",     // 155
  "Conductivity K Factor",        // 156
  "Sreen Refresh Time",           // 157
  "Damping Time",                 // 158
  "Uptade Software",              // 159
  "DN 32",                        // 160
  "DN 40",                        // 161
  "DN 45",                        // 162
  "DN 50",                        // 163
  "DN 55",                        // 164
  "DN 65",                        // 165
  "DN 70",                        // 166
  "DN 75",                        // 167
  "DN 80",                        // 168
  "DN 85",                        // 169
  "DN 90",                        // 170
  "DN 95",                        // 171
  "DN 100",                       // 172
  "DN 125",                       // 173
  "DN 150",                       // 174
  "DN 200",                       // 175
  "DN 250",                       // 176
  "DN 300",                       // 177
  "DN 320",                       // 178
  "DN 350",                       // 179
  "DN 400",                       // 180
  "DN 450",                       // 181
  "DN 500",                       // 182
  "DN 550",                       // 183
  "DN 600",                       // 184
  "DN 650",                       // 185
  "DN 700",                       // 186
  "DN 750",                       // 187
  "DN 800",                       // 188
  "DN 850",                       // 189
  "DN 900",                       // 190
  "DN 950",                       // 191
  "DN 1000",                      // 192
  "DN 1100",                      // 193
  "DN 1200",                      // 194
  "DN 1300",                      // 195
  "DN 1400",                      // 196
  "DN 1500",                      // 197
  "DN 1600",                      // 198
  "DN 1700",                      // 199
  "DN 1800",                      // 200
  "DN 1900",                      // 201
  "DN 2000",                      // 202
  "DN 2100",                      // 203
  "DN 2200",                      // 204
  "DN 2300",                      // 205
  "DN 2400",                      // 206
  "DN 2500",                      // 207
  "DN 2600",                      // 208
  "DN 2700",                      // 209
  "DN 2800",                      // 210
  "DN 2900",                      // 211
  "DN 3000",                      // 212
  "DN 4000",                      // 213
  "m3",                           // 214
  "L",                            // 215
  "m3 / h",                       // 216
  "L / h",                        // 217
  "Min Frequency",                // 218
  "1 Second",                     // 219
  "2 Seconds",                    // 220
  "4 Seconds",                    // 221
  "6 Seconds",                    // 222
  "8 Seconds",                    // 223
  "10 Seconds",                   // 224
  "16 Seconds",                   // 225
  "30 Seconds",                   // 226
  "40 Seconds",                   // 227
  "60 Seconds",                   // 228
  "Alarm output",                 // 229
  "High Flow", // 230
  "Low Flow", // 231
  "Empty Pipe", // 232
  "Reverse Direction", // 233
  "System", // 234
  "Disable Alarm", // 235
};

char *turkish[] = {
  "Haslo",                          // 0
  "Podaj haslo",             // 1
  "Gotowe !",                    // 2
  "Nieprawidlowe haslo! Sprobuj ponownie",  // 3
  "Podstawowe ustawienia",                  // 4
  "Ustawienia zaawansowane ",               // 5
  "Wyjscie",                 // 6
  "Komunikacja",                       // 7
  "Wyswietlacz",                          // 8
  "Rejestr danych",                     // 9
  "Informacje",                  // 10
  "MENU",                           // 11
  "MSJ :",                          // 12
  "S",                              // 13
  "KD EMDE V2.0",                   // 14
  "Jezyk",                            // 15
  "Parametry przeplywu",             // 16
  "Rozmiar czujnika",                       // 17
  "Zerowanie funkcji",                 // 18
  "Gestosc- Przewodnosc",          // 19
  "Zmiana hasla",                 // 20
  "Reset",                          // 21
  "Dokladna kalibracja ",             // 22
  "Miernik- wsplczynnik K",              // 23
  "Wyjscie analogowe",                   // 24
  "Wyjscie cyfrowe",                  // 25
  "Wybor motywu",                    // 26
  "Linia 1",                        // 27
  "Linia 2",                        // 28
  "Numer seryjny",                  // 29
  "Data produkcji",                    // 30
  "Informacje",                  // 31
  "Jednostka przeplywu",                    // 32
  "Zakres przeplywu",                  // 33
  "Przecinek",                  // 34
  "Czas reakcji",                   // 35
  "odciecie",              // 36
  "Kierunek przeplywu",                      // 37
  "Jednostka interwalu",                  // 38
  "Czas interwalu",                  // 39
  "Modbus",                         // 40
  "Ethernet             [NA]",      // 41
  "Hart                    [NA]",   // 42
  "Profibus             [NA]",      // 43
  "Bluetooth           [NA]",       // 44
  "Wi-Fi",                          // 45
  "[NA]",                           // 46
  "Funkcje",                   // 47
  "Automatyczne zerowanie",             // 48
  "Zerowanie reczne",               // 49
  "Szybkosc transmisji modus",                // 50
  "ID modbus",                      // 51
  "Bit parzystosci modbus",              // 52
  "0 - 10 V",                       // 53
  "4 - 20 mA",                      // 54
  "Wyjscie cyfrowe 1",                // 55
  "Wyjscie cyfrowe 2",                // 56
  "Wyjscie cyfrowe 3",                // 57
  "0 - 10 mA",                      // 58
  "0 - 20 mA",                      // 59
  "4 - 12 - 20 mA",                 // 60
  "Impuls-Czestotliwosc",                // 61
  "Alarm wysoki",                   // 62
  "Alarm niski",                    // 63
  "Przewodnosc",                     // 64
  "Alarm systemowy",                   // 65
  "Kierunek",                            // 66
  "Impuls",                          // 67
  "Czestotliwosc",                        // 68
  "Zakres",                         // 69
  "None",                           // 70
  "Odd",                            // 71
  "Even",                           // 72
  "Poza zakresem",               // 73
  "Jednostka gestosci",                // 74
  "Wartosc gestosci",                // 75
  "Aktywne",                          // 76
  "Pasywne",                          // 77
  "Angielski",                      // 78
  "Polski",                         // 79
  "Dalej",                          // 80
  "Cofnij",                           // 81
  "Wyjscie analogowe 1 mA",             // 82
  "Wyjscie analogowe 2 mA",             // 83
  "Rodzaj wyjscia",                     // 84
  "Przeplyw",                           // 85
  "Temperatura",                       // 86
  "Przewodnosc",                     // 87
  "Tylko dla przeplywu",            // 88
  "Dalej - cofnij",                   // 89
  "TAK",                           // 90
  "NIE",                          // 91
  "Wprowadz prawidlowe haslo",   // 92
  "Wprowadz nowe haslo",      // 93
  "Haslo zostalo zmienione",             // 94
  "Ustawienia fabryczne",               // 95
  "Reset calowity",            // 96
  "Cofnij calkowity reset",             // 97
  "Bit stopu Modbus",                // 98
  "Motyw ciemny",                      // 99
  "Motyw jasny",                     // 100
  "Wyjscie analogowe 3 VDC",            // 101
  "Tryb testowy",                      // 102
  "Kalibracja wyjscia",             // 103
  "Regulacja 4 mA",                    // 104
  "Regulacja 20 mA",                   // 105
  "Regulacja 0 V",                     // 106
  "Regulacja 10 V",                    // 107
  "K Factor",                      // 108
  "Jednostki",                       // 109
  "Liczba jednostek",                   // 110
  "Wrazliwosc",                     // 111
  "Meter Faktor",                  // 112
  "Przewodnosc",                     // 113
  "Gestosc",                       // 114
  "Tryb aplikacji",                  // 115
  "Czestotliwosc czujnika",                // 116
  "Punkt 1",                       // 117
  "Wartosc 1",                       // 118
  "Punkt 2",                       // 119
  "Wartosc 2",                       // 120
  "Punkt 3",                       // 121
  "Wartosc 3",                       // 122
  "Punkt 4",                       // 123
  "Wartosc 4",                       // 124
  "Dokladna kalibracja",        // 125
  "Normalny",                         // 126
  "Zawiesina",         // 127
  "Uruchom",                          // 128
  "Zamknij",                          // 129
  "Alarm",                          // 130
  "Alarm PL",                     // 131
  "Opcja alamu",              // 132
  "Tryb alarmu",                     // 133
  "Wartosc alarmu",                   // 134
  "Alarm wyjsciowy",                     // 135
  "Alarm wysoki",                    // 136
  "Alarm niski",                    // 137
  "Alarm systemowy",              // 138
  "Q [%]",                          // 139
  "Q [jednoska]",                      // 140
  "Calosc netto",                      // 141
  "Calosc dalej",                    // 142
  "Calosc powrot",                     // 143
  "Aktywny Wysoki",                   // 144
  "Aktywny niski",                    // 145
  "Funkcja wysokiego alarmu",       // 146
  "Funkcja niskiego alarmu",        // 147
  "Wspolczynnik impulsu",                  // 148
  "Szerokosc imulsu",                // 149
  "Max. czesotliwosc",                    // 150
  "Test impulsow",                     // 151
  "Funkcja wyjscia",            // 152
  "Ustawienia Impulsu",                 // 153
  "Szybka konfiguracja",                  // 154
  "Wartosc alarmu przewodnosci",        // 155
  "Wspolczynnik przewodności K",           // 156
  "Czas odswiezania ekranu",         // 157
  "Czas tlumienia",               // 158
  "Aktualizacja oprogramowania",              // 159
  "DN 32",                          // 160
  "DN 40",                          // 161
  "DN 45",                          // 162
  "DN 50",                          // 163
  "DN 55",                          // 164
  "DN 65",                          // 165
  "DN 70",                          // 166
  "DN 75",                          // 167
  "DN 80",                          // 168
  "DN 85",                          // 169
  "DN 90",                          // 170
  "DN 95",                          // 171
  "DN 100",                         // 172
  "DN 125",                         // 173
  "DN 150",                         // 174
  "DN 200",                         // 175
  "DN 250",                         // 176
  "DN 300",                         // 177
  "DN 320",                         // 178
  "DN 350",                         // 179
  "DN 400",                         // 180
  "DN 450",                         // 181
  "DN 500",                         // 182
  "DN 550",                         // 183
  "DN 600",                         // 184
  "DN 650",                         // 185
  "DN 700",                         // 186
  "DN 750",                         // 187
  "DN 800",                         // 188
  "DN 850",                         // 189
  "DN 900",                         // 190
  "DN 950",                         // 191
  "DN 1000",                        // 192
  "DN 1100",                        // 193
  "DN 1200",                        // 194
  "DN 1300",                        // 195
  "DN 1400",                        // 196
  "DN 1500",                        // 197
  "DN 1600",                        // 198
  "DN 1700",                        // 199
  "DN 1800",                        // 200
  "DN 1900",                        // 201
  "DN 2000",                        // 202
  "DN 2100",                        // 203
  "DN 2200",                        // 204
  "DN 2300",                        // 205
  "DN 2400",                        // 206
  "DN 2500",                        // 207
  "DN 2600",                        // 208
  "DN 2700",                        // 209
  "DN 2800",                        // 210
  "DN 2900",                        // 211
  "DN 3000",                        // 212
  "DN 4000",                        // 213
  "m3",                             // 214
  "L",                              // 215
  "m3 / h",                         // 216
  "L / h",                          // 217
  "Min Frekans",                    // 218
  "1 drugi",                       // 219
  "2 drugi",                       // 220
  "4 drugi",                       // 221
  "6 drugi",                       // 222
  "8 drugi",                       // 223
  "10 drugi",                      // 224
  "16 drugi",                      // 225
  "30 drugi",                      // 226
  "40 drugi",                      // 227
  "60 drugi",                      // 228
  "Wyjscie alarmowe",                    // 229
  "Wysoki przeplyw", // 230
  "Niski przeplyw", // 231
  "Pusta rura", // 232
  "Przeplyw wsteczny", // 233
  "System", // 234
  "Brak alarmu", // 235
};


// char *turkish[] = {
//   "Sifre",                          // 0
//   "Lutfen sifre girin",             // 1
//   "onaylandi !",                    // 2
//   "Sifre yanlis ! Tekrar deneyin",  // 3
//   "Temel Ayarlar",                  // 4
//   "Gelismis Ayarlar",               // 5
//   "Cikis Ayarlari",                 // 6
//   "Iletisim",                       // 7
//   "Ekran",                          // 8
//   "Veri Kayit",                     // 9
//   "Bilgilendirme",                  // 10
//   "MENU",                           // 11
//   "MSJ :",                          // 12
//   "S",                              // 13
//   "KD EMDE V2.0",                   // 14
//   "Dil",                            // 15
//   "Akis Parametreleri",             // 16
//   "Hat Capi",                       // 17
//   "Akis Sifirlama",                 // 18
//   "Yogunluk - Iletkenlik",          // 19
//   "Sifre Degistir",                 // 20
//   "Reset",                          // 21
//   "Hassas Kalibrasyon",             // 22
//   "Metre - K Faktoru",              // 23
//   "Analog cikis",                   // 24
//   "Digital Cikis",                  // 25
//   "Tema Secimi",                    // 26
//   "Satir 1",                        // 27
//   "Satir 2",                        // 28
//   "Seri Numarasi",                  // 29
//   "Urun Tarihi",                    // 30
//   "Bilgilendirme",                  // 31
//   "Akis Birimi",                    // 32
//   "Olcme Araligi",                  // 33
//   "Ondalik Nokta",                  // 34
//   "Cevap suresi",                   // 35
//   "Akis Kesim ",              // 36
//   "Akis Yonu",                      // 37
//   "Aralik Birimi",                  // 38
//   "Aralik Zamani",                  // 39
//   "Modbus",                         // 40
//   "Ethernet             [NA]",      // 41
//   "Hart                    [NA]",   // 42
//   "Profibus             [NA]",      // 43
//   "Bluetooth           [NA]",       // 44
//   "Wi-Fi",                          // 45
//   "[NA]",                           // 46
//   "Fonksiyonlar",                   // 47
//   "Otomatik Sifirlama",             // 48
//   "Manuel Sifirlama",               // 49
//   "Modbus Baudrate",                // 50
//   "Modbus ID",                      // 51
//   "Modbus Parity Bit",              // 52
//   "0 - 10 V",                       // 53
//   "4 - 20 mA",                      // 54
//   "Dijital Cikis 1",                // 55
//   "Dijital Cikis 2",                // 56
//   "Dijital Cikis 3",                // 57
//   "0 - 10 mA",                      // 58
//   "0 - 20 mA",                      // 59
//   "4 - 12 - 20 mA",                 // 60
//   "Pulse - Frekans",                // 61
//   "Alarm Yuksek",                   // 62
//   "Alarm Dusuk",                    // 63
//   "Iletkenlik",                     // 64
//   "Sistem Alarm",                   // 65
//   "Yon",                            // 66
//   "Pulse",                          // 67
//   "Frekans",                        // 68
//   "Aralik",                         // 69
//   "None",                           // 70
//   "Odd",                            // 71
//   "Even",                           // 72
//   "araligin disinda",               // 73
//   "Yogunluk Birimi",                // 74
//   "Yogunluk Degeri",                // 75
//   "aktif",                          // 76
//   "pasif",                          // 77
//   "Ingilizce",                      // 78
//   "Polski",                         // 79
//   "Ileri",                          // 80
//   "Geri",                           // 81
//   "Analog Cikis 1  mA",             // 82
//   "Analog Cikis 1  mA",             // 83
//   "Cikis Tipi",                     // 84
//   "Akis",                           // 85
//   "Sicaklik",                       // 86
//   "Ilenkenlik",                     // 87
//   "yalniz akis icindir",            // 88
//   "Ileri - Geri",                   // 89
//   "EVET",                           // 90
//   "HAYIR",                          // 91
//   "Lutfen gecerli sifreyi girin",   // 92
//   "Lutfen yeni sifreyi girin",      // 93
//   "Sifre degistirildi",             // 94
//   "Fabrika Ayarlari",               // 95
//   "Ileri Total Sifirla",            // 96
//   "Geri Total Sifirla",             // 97
//   "Modbus Stop bit",                // 98
//   "Koyu Tema",                      // 99
//   "Beyaz Tema",                     // 100
//   "Analog Cikis 2  VDC",            // 101
//   "Test Modu",                      // 102
//   "Cikis Kalibrasyonu",             // 103
//   "Ayarla 4 mA",                    // 104
//   "Ayarla 20 mA",                   // 105
//   "Ayarla 0 V",                     // 106
//   "Ayarla 10 V",                    // 107
//   "K Factoru",                      // 108
//   "Birimler",                       // 109
//   "Toplam Birim",                   // 110
//   "Duyarlilik",                     // 111
//   "Metre Faktoru",                  // 112
//   "Iletkenlik",                     // 113
//   "Yogunluk",                       // 114
//   "Uygulama Modu",                  // 115
//   "Sensor Frekansı",                // 116
//   "1. Nokta",                       // 117
//   "1. Deger",                       // 118
//   "2. Nokta",                       // 119
//   "2. Deger",                       // 120
//   "3. Nokta",                       // 121
//   "3. Deger",                       // 122
//   "4. Nokta",                       // 123
//   "4. Deger",                       // 124
//   "Hassas Kalibrasyon Akt.",        // 125
//   "Normal",                         // 126
//   "Parcacik ve Bulaniklik",         // 127
//   "Aktif",                          // 128
//   "Pasif",                          // 129
//   "Alarm",                          // 130
//   "Alarm Akt.",                     // 131
//   "Alarm Secenekleri",              // 132
//   "Alarm Modu",                     // 133
//   "Alarm Degeri",                   // 134
//   "Alarm Iout",                     // 135
//   "Yuksek Akis Alarm",                    // 136
//   "Dusuk Akis Alarm",                    // 137
//   "Sistem Alarm Akt.",              // 138
//   "Q [%]",                          // 139
//   "Q [birim]",                      // 140
//   "Total Net",                      // 141
//   "Total Ileri",                    // 142
//   "Total Geri",                     // 143
//   "Aktif Yuksek",                   // 144
//   "Aktif Dusuk",                    // 145
//   "Yuksek Alarm Cikis Fonk.",       // 146
//   "Dusuk Alarm Cikis Fonk.",        // 147
//   "Pulse Faktoru",                  // 148
//   "Pulse Genisligi",                // 149
//   "Max Frekans",                    // 150
//   "Pulse Test",                     // 151
//   "Cikis Fonksiyonları",            // 152
//   "Pulse Ayarlari",                 // 153
//   "Hizli Kurulum",                  // 154
//   "iletkenlik Alarm Degeri",        // 155
//   "iletkenlik K Faktoru",           // 156
//   "Ekran Yenilenme Suresi",         // 157
//   "Sonumleme Suresi",               // 158
//   "Yazilimi Guncelle",              // 159
//   "DN 32",                          // 160
//   "DN 40",                          // 161
//   "DN 45",                          // 162
//   "DN 50",                          // 163
//   "DN 55",                          // 164
//   "DN 65",                          // 165
//   "DN 70",                          // 166
//   "DN 75",                          // 167
//   "DN 80",                          // 168
//   "DN 85",                          // 169
//   "DN 90",                          // 170
//   "DN 95",                          // 171
//   "DN 100",                         // 172
//   "DN 125",                         // 173
//   "DN 150",                         // 174
//   "DN 200",                         // 175
//   "DN 250",                         // 176
//   "DN 300",                         // 177
//   "DN 320",                         // 178
//   "DN 350",                         // 179
//   "DN 400",                         // 180
//   "DN 450",                         // 181
//   "DN 500",                         // 182
//   "DN 550",                         // 183
//   "DN 600",                         // 184
//   "DN 650",                         // 185
//   "DN 700",                         // 186
//   "DN 750",                         // 187
//   "DN 800",                         // 188
//   "DN 850",                         // 189
//   "DN 900",                         // 190
//   "DN 950",                         // 191
//   "DN 1000",                        // 192
//   "DN 1100",                        // 193
//   "DN 1200",                        // 194
//   "DN 1300",                        // 195
//   "DN 1400",                        // 196
//   "DN 1500",                        // 197
//   "DN 1600",                        // 198
//   "DN 1700",                        // 199
//   "DN 1800",                        // 200
//   "DN 1900",                        // 201
//   "DN 2000",                        // 202
//   "DN 2100",                        // 203
//   "DN 2200",                        // 204
//   "DN 2300",                        // 205
//   "DN 2400",                        // 206
//   "DN 2500",                        // 207
//   "DN 2600",                        // 208
//   "DN 2700",                        // 209
//   "DN 2800",                        // 210
//   "DN 2900",                        // 211
//   "DN 3000",                        // 212
//   "DN 4000",                        // 213
//   "m3",                             // 214
//   "L",                              // 215
//   "m3 / h",                         // 216
//   "L / h",                          // 217
//   "Min Frekans",                    // 218
//   "1 Saniye",                       // 219
//   "2 Saniye",                       // 220
//   "4 Saniye",                       // 221
//   "6 Saniye",                       // 222
//   "8 Saniye",                       // 223
//   "10 Saniye",                      // 224
//   "16 Saniye",                      // 225
//   "30 Saniye",                      // 226
//   "40 Saniye",                      // 227
//   "60 Saniye",                      // 228
//   "Alarm cikis",                    // 229
//   "Yuksek Akis", // 230
//   "Dusuk Akis", // 231
//   "Bos Boru", // 232
//   "Ters Akis", // 233
//   "Sistem", // 234
//   "Alarm yok", // 235
// };

// Birimler
char *units[] = {
  "g / cm3",       // 0
  "kg / m3",       // 1
  "Lb / ukgal",    // 2
  "Lb / f3",       // 3
  "m3 / s",        // 4
  "m3 / m",        // 5
  "m3 / h",        // 6
  "L / s",         // 7
  "L / m",         // 8
  "L / h",         // 9
  "ft3 / s",       // 10
  "ft3 / m",       // 11
  "ft3 / h",       // 12
  "ukgal / s",     // 13
  "ukgal / m",     // 14
  "ukgal / h",     // 15
  "usgal / s",     // 16
  "usgal / m",     // 17
  "usgal / h",     // 18
  "kg / s",        // 19
  "kg / m",        // 20
  "kg / h",        // 21
  "t / s",         // 22
  "t / m",         // 23
  "t / h",         // 24
  "Lb / s",        // 25
  "Lb / m",        // 26
  "Lb / h",        // 27
  "Lb / usgal",    // 28
  "0 - 5 - 10 V",  // 29
  "4 mA",          // 30
  "12 mA",         // 31
  "20 mA",         // 32
  "5 V",           // 33
  "10 V",          // 34
  "m3",            // 35
  "L",             // 36
  "ft3",           // 37
  "ukgal",         // 38
  "usgal",         // 39
  "kg",            // 40
  "t",             // 41
  "Lb",            // 42
  "5 Hz",          // 43
  "4.167 Hz",      // 44
  "3.125 Hz",      // 45
};


// DEĞİŞKENLER
// Ayarlanabilir
uint8_t slave_ID = 1;
uint16_t baud_rate_value = 9600;
uint16_t parity_bit_value = 0;  // None = 0, Odd = 1, Even = 2
uint16_t stop_bit_value = 1;
uint16_t main_password = 0000;
const uint16_t master_password = 1863;
uint8_t theme_color = dark_theme;
float screen_refresh_time_value = 1;  //

// Holding register değişkenleri
const uint8_t holding_registers_quantity = 14;
uint16_t holdingRegisters[holding_registers_quantity];  // Toplamda 6 adet 16-bit register (3 float, 1 int32, 2 uint32)

float flow;                  // anlık akış
float flow_rate;             // akış hızı
float mA_out;                // out mA çıkış
int32_t total_differential;  // total fark
uint32_t total_positive;     // total ileri yön
uint32_t total_negative;     // total geri yön
float level;                 // seviye

uint16_t flow_address = 0,
         flow_rate_address = 2,
         mA_out_address = 4,
         total_differential_address = 6,
         total_positive_address = 8,
         total_negative_address = 10,
         level_address = 12;

uint16_t register_adress = 10000;  // slave registarlara yazma işlemi olduysa o register ın adresini alır

// Cihaz parametleri
uint16_t language = English;
uint16_t flow_unit_value = 0, total_unit_value = 0;
uint16_t flow_direction_value = 0;
uint16_t density_unit_value = 0;
uint16_t analog_out_1_type = 0, analog_out_2_type = _ma_4_20, analog_out_3_type = v_0_10;
uint16_t measure_mode_value = 0;
float flow_zero_value = 0;

// Fonksiyonlar arası kullanılan değişkenler
uint8_t screen_switch = main_screen;
uint8_t previous_screen_switch = 0;  // başlangıç ekranını seç
volatile uint8_t button_state = 0;
uint8_t idle = 0;
bool page_change = true;                        // sayfa numarası değişimi takibi için
unsigned long last_time = 0, current_time = 0;  // zamanlama değişkenleri
float time_for_main_sreens = 0, conductivity_temperature_second = 0;
uint8_t half_second = 0, second_for_outputs_set = 0, second_for_menu = 0;  // zamanlama değişkenleri
uint8_t password_validity_time = 150;                                      // zamanlama değişkenleri
int16_t cursor = 0, previous_cursor = 0;                                   // menu ekranı setting seçim değişkeni
bool sign_digit, sign_state, decimal_state;                                // Sayı giriş ekranı "+" "- " işaret durumu değişkeni
int8_t number[8];
int8_t digit, previous_digit, fixed_digit = 0;  // Sayı giriş ekranı kırmızı çizgi konumu
float read_or_write_number;                     // Veri giriş ekranı sayısı
uint8_t time_after_communication = 8;           // modbus haberleşmesi ardından bir sonraki haberleşme ile çakışma olmaması için beklenecek süre ms cinsinden
float previous_flow_rate = 0;                   // Automatic zero için bir önceki akış hızı
char flow_buffer[35], total_buffer[35];
uint16_t previous_flow_unit;
float percentage;                                                                                  // anlık akış yüzdesi
uint16_t upper_limit_VDC = 201, lower_limit_VDC = 2, upper_limit_mA = 2567, lower_limit_mA = 482;  // kalibrasyon değerleri
uint16_t calibration_value;                                                                        // kalibrasyon ekranındaki değişen sayı
uint16_t digital_out_selection;
uint8_t page_number;
bool opening_page = true;                          // sayfa ilk görüntüsünü bir kez basma için onay değişkeni
bool left_aligned = true, middle_aligned = false;  // bar stil seçimi
uint16_t tick_location, previous_tick_location = 0;
uint16_t alarm_state = 0, previous_alarm_state = 0, D_out_2_alarm_state = 4, D_out_3_alarm_state = 8;  // Alarm durumu registerı
uint8_t alarm_time_counter;
float volatile_float;
uint16_t volatile_uint16;
float conductivity_k_factor_value = 1;
float flow_range_value;
uint32_t total_eeprom_positive = 0;     // total ileri yön
uint32_t total_eeprom_negative = 0;     // total geri yön
uint8_t screen_total_choice = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Buton düzeltme için ekleme kodlar

// Ortak işlemlerde kullandığın değişkenler (projende varsa extern yap)

const uint32_t DEBOUNCE_MS = 60;
const uint32_t QUIET_MS    = 100;

volatile uint32_t quiet_until = 0;

// ESC
volatile uint32_t esc_count = 0;
volatile bool     esc_locked = false;
volatile uint32_t esc_tedge  = 0;

// UP
volatile uint32_t up_count = 0;
volatile bool     up_locked = false;
volatile uint32_t up_tedge  = 0;

// DOWN
volatile uint32_t down_count = 0;
volatile bool     down_locked = false;
volatile uint32_t down_tedge  = 0;

// ENTER
volatile uint32_t enter_count = 0;
volatile bool     enter_locked = false;
volatile uint32_t enter_tedge  = 0;

// Yardımcı
static inline bool pin_low(int pin){ return digitalRead(pin) == LOW; }
static inline bool pin_high(int pin){ return !pin_low(pin); }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// wifi parametleri
const char *ssid = "bass";          // Wi-Fi SSID
const char *password = "12345678";  // Wi-Fi Password
const char *firmwareUrl = "https://raw.githubusercontent.com/BassInstruments/PARTIAL_FILLED_EMDE_PCB_V2/main/Partial_Filled_EMDE.ino.bin";

// NESNELER
ModbusMaster modbus_master;                        // Modbus master nesnesini olustur
ModbusRTUSlave modbus_slave(Serial, DE_RE_PIN_1);  // Modbus slave nesnesini oluştur
TFT_eSPI tft = TFT_eSPI();                         // TFT nesnesini olustur
MCP4725 MCP(MPC_DAC_ADDRESS);                      // Akım çıkışı için MCP nesnesi oluştur

// BUTON KESMESİ FONKSİYON PROTOTİPLERİ
void IRAM_ATTR esc_button_interrupt();
void IRAM_ATTR up_button_interrupt();
void IRAM_ATTR down_button_interrupt();
void IRAM_ATTR enter_button_interrupt();
void IRAM_ATTR serial_interrupt();

void setup() {

  digitalWrite(LCD_BLK, LOW);

  // Modbus haberleşme pinlerini ayarla

  // pinMode(DE_RE_PIN_1, OUTPUT);
  // pinMode(DE_RE_PIN_2, OUTPUT);

  pinMode(relay_pin, OUTPUT);
  pinMode(pulse_pin, OUTPUT);

  pinMode(esc_button, INPUT);    // Dahili pull-up direncini etkinleştir
  pinMode(up_button, INPUT);     // Dahili pull-up direncini etkinleştir
  pinMode(down_button, INPUT);   // Dahili pull-up direncini etkinleştir
  pinMode(enter_button, INPUT);  // Dahili pull-up direncini etkinleştir

  // // baslangicta modbus dinleme modunda
  // digitalWrite(DE_RE_PIN_1, LOW);
  // digitalWrite(DE_RE_PIN_2, LOW);

  // baslangicta cikislar düsük modda
  digitalWrite(relay_pin, LOW);
  digitalWrite(pulse_pin, LOW);

  pinMode(LCD_BLK, OUTPUT);

  // Buton kesme fonksiyonlarını butonlarla bağla
  attachInterrupt(esc_button, esc_button_interrupt, CHANGE);      //  kesme tanımla
  attachInterrupt(up_button, up_button_interrupt, CHANGE);        //  kesme tanımla
  attachInterrupt(down_button, down_button_interrupt, CHANGE);    //  kesme tanımla
  attachInterrupt(enter_button, enter_button_interrupt, CHANGE);  //  kesme tanımla

  // Serial (programlama uartı) kesmesi tanımlaması
  Serial.onReceive(serial_interrupt);

  EEPROM.begin(64);  // Eppromda 64 byte lık yer ayrıldı

  Wire.begin();  // I2C haberleşmesi için
  MCP.begin();   // Akım çıkışı için

  Serial2.begin(9600, SERIAL_8N1, MASTER_RX_PIN, MASTER_TX_PIN);
  modbus_master.begin(1, Serial2);  // Modbus master için slave ID = 1, UART 2 kullan

  tft.init();
  // tft.setRotation(1);  // düz
  tft.setRotation(3); // ters
  tft.setSwapBytes(true);

  delay(1000);
  digitalWrite(LCD_BLK, HIGH);
  beginning_logo_animation();

  // İlk çalışmada eepromu default değerlerle doldur
  if (EEPROM.readByte(eeprom_write_status_address) == 10) {  // eeprom a ilk değerlerin atamasının yapıldığı bilgisini taşıyan register adresine random atanan 697 değerini kontrol et.
    // ilk değer atamaları yapıldıysa değerleri kullanmak için değişkenlere ata
    slave_ID = EEPROM.readByte(slave_ID_eep_address);
    theme_color = EEPROM.readByte(theme_color_address);
    main_password = EEPROM.readUShort(main_password_address);
    baud_rate_value = EEPROM.readUShort(modbus_baud_rate_address);
    parity_bit_value = EEPROM.readUShort(modbus_parity_bit_address);
    stop_bit_value = EEPROM.readUShort(modbus_stop_bit_address);
    previous_flow_rate = EEPROM.readFloat(previous_flow_rate_adress);
    analog_out_2_type = EEPROM.readUShort(analog_out_2_type_address);
    analog_out_3_type = EEPROM.readUShort(analog_out_3_type_address);
    upper_limit_VDC = EEPROM.readUShort(upper_limit_VDC_address);
    lower_limit_VDC = EEPROM.readUShort(lower_limit_VDC_address);
    upper_limit_mA = EEPROM.readUShort(upper_limit_mA_address);
    lower_limit_mA = EEPROM.readUShort(lower_limit_mA_address);
    D_out_2_alarm_state = EEPROM.readUShort(D_out_2_alarm_state_address);
    D_out_3_alarm_state = EEPROM.readUShort(D_out_3_alarm_state_address);
    screen_total_choice = EEPROM.readUShort(screen_total_choice_address);
    total_eeprom_positive = EEPROM.readULong(total_eeprom_positive_address);
    total_eeprom_negative = EEPROM.readULong(total_eeprom_negative_address);
    conductivity_k_factor_value = EEPROM.readFloat(conductivity_k_factor_register_address);
    screen_refresh_time_value = EEPROM.readFloat(screen_refresh_time_value_address);

  } else {  // ilk değer atamaları yapılmadıysa ilk değerleri ata
    EEPROM.writeByte(slave_ID_eep_address, slave_ID);
    EEPROM.writeByte(theme_color_address, theme_color);
    EEPROM.writeByte(eeprom_write_status_address, 10);         // eeprom a ilk değerlerin atamasının yapıldığı bu değişkene örneğin 10 değerini kaydederek göster
    EEPROM.writeUShort(main_password_address, main_password);  // şifre değişiminde eeproma bu şekilde yazılacak
    EEPROM.writeUShort(modbus_baud_rate_address, 9600);
    EEPROM.writeUShort(modbus_parity_bit_address, parity_bit_value);
    EEPROM.writeUShort(modbus_stop_bit_address, stop_bit_value);
    EEPROM.writeUShort(analog_out_2_type_address, _ma_4_20);
    EEPROM.writeUShort(analog_out_3_type_address, v_0_10);
    EEPROM.writeUShort(upper_limit_VDC_address, upper_limit_VDC);
    EEPROM.writeUShort(lower_limit_VDC_address, lower_limit_VDC);
    EEPROM.writeUShort(upper_limit_mA_address, upper_limit_mA);
    EEPROM.writeUShort(lower_limit_mA_address, lower_limit_mA);
    EEPROM.writeUShort(D_out_2_alarm_state_address, D_out_2_alarm_state);
    EEPROM.writeUShort(D_out_3_alarm_state_address, D_out_3_alarm_state);
    EEPROM.writeUShort(screen_total_choice_address, screen_total_choice);
    EEPROM.writeULong(total_eeprom_positive_address, total_eeprom_positive);  
    EEPROM.writeULong(total_eeprom_negative_address, total_eeprom_negative);  
    EEPROM.writeFloat(previous_flow_rate_adress, 0);
    EEPROM.writeFloat(conductivity_k_factor_register_address, conductivity_k_factor_value);
    EEPROM.writeFloat(screen_refresh_time_value_address, screen_refresh_time_value);

    EEPROM.commit();  // kaydet
  }

  // Stop bit ve parity bit ayarlarının hafızadan çekilmesi
  if (stop_bit_value == 1) {
    if (parity_bit_value == 0) {
      modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N1, SLAVE_RX_PIN, SLAVE_TX_PIN);
    } else if (parity_bit_value == 1) {
      modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O1, SLAVE_RX_PIN, SLAVE_TX_PIN);
    } else if (parity_bit_value == 2) {
      modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E1, SLAVE_RX_PIN, SLAVE_TX_PIN);
    }
  } else if (stop_bit_value == 2) {
    if (parity_bit_value == 0) {
      modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N2, SLAVE_RX_PIN, SLAVE_TX_PIN);
    } else if (parity_bit_value == 1) {
      modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O2, SLAVE_RX_PIN, SLAVE_TX_PIN);
    } else if (parity_bit_value == 2) {
      modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E2, SLAVE_RX_PIN, SLAVE_TX_PIN);
    }
  }

  modbus_slave.configureHoldingRegisters(holdingRegisters, holding_registers_quantity);  // Tek bir dizi içinde tüm holding registerlar

  // Callbacks allow us to configure the RS485 transceiver correctly
  modbus_master.preTransmission(preTransmission);
  modbus_master.postTransmission(postTransmission);

  // İlk haberleşme geçersiz oluyor
  modbus_master.read_or_write(1, READ_HOLDING, 0x31, &language);
  delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

  // Dili seç
  modbus_master.read_or_write(1, READ_HOLDING, 0x31, &language);
  delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

  // MCP.setValue(1000);
}

void loop() {

  // Zamanlamayı çalıştır
  count_second();

  // Ekrana görüntü bas (içindeki modbus haberleşmelerinden kaynaklık olarak ms mertebesinden gecikmeleri mevcut)
  screen();

  modbus_rx();
}
/*******************************************************************************************************************************************/


/*******************************************************************************************************************************************/
// KONTROL FONKSİYONLARI
void screen() {  // bu fonksiyonu sürekli tekrarlar

  bool high_light = true, low_light = false;  // bar aydınlatma değişkenleri
  static uint16_t uint16_value;
  int16_t int16_value;
  int32_t int32_value;
  bool decimal_number = true, non_decimal_number = false;
  bool non_positive = true, positive = false;
  uint16_t language_state = 0;
  char calibration_value_buffer[6];
  uint16_t percentage_bar;
  static uint8_t previous_half_second;
  static bool green_rectengular = true;
  static uint16_t alarm_Iout_enable;
  static float temperature, mtp_value;
  static uint16_t decpoint = 1;  // anlık akış ekranda göstereceği ondalık sayısı
  static bool first_text = false;
  static bool alarm_animation = true;  // Alarm animasyonu için tersleme değişkeni
  static uint8_t alarm_counter = 0;    // birden çok alarm gösterme değişkeni
  static float V;                      // out mA çıkış
  uint16_t dac_ma_value, dac_v_value;
  float percentage_V;
  uint16_t protect_password = 19818;  // yazma yetkisi şifresi
  uint16_t pulse_unit;
  static char flow_buffer[35], total_buffer_main_screen[20], level_buffer[10], velocity_buffer[10], conductivity_value_buffer[15], total_forward_buffer[35], total_reverse_buffer[35];  // Sayıyı depolamak için yeterli büyüklükte bir dizi

  const uint16_t *icons_main[] = {
    basic_settings_icon,
    advanced_setting_icon,
    output_icon,
    communication_icon,
    display_icon,
    data_logging_icon,
    Information_icon
  };


  // Sayfa seçimi
  switch (screen_switch) {
    case main_screen:

      percentage_bar = percentage;
      if (percentage_bar < 0) percentage_bar = percentage_bar * -1;  // eksi ile barı dolduramayacağı için pozitif yapılıyor
      if (percentage_bar > 100) percentage_bar = 100;                // Bar ın taşmaması için limitle

      if (opening_page == true) {
        opening_page = false;
        page_change = true;  // sayfa değişimi olduğunu anlama için
        alarm_time_counter = 0;
        theme_color = white_theme;  // sil
        tft.fillScreen(TFT_WHITE);
        tft.setTextColor(TFT_BLACK, TFT_WHITE);

        tft.fillRect(0, 0, 320, 35, TFT_BLUEE);

        tft.drawLine(15, 112, 305, 112, TFT_BLUE);

        tft.setTextColor(TFT_WHITE, TFT_BLUEE);
        tft.setTextDatum(TR_DATUM);  // Sağa yaslı hizalama
        tft.drawString(level_buffer, 85, 6, FONT4);
        tft.drawString(velocity_buffer, 270, 6, FONT4);
        tft.setTextDatum(TL_DATUM);  // Sağa yaslı hizalama

        tft.setFreeFont(FSS9);
        tft.drawString("L", 5, 10);
        tft.drawString("mm", 90, 11);
        tft.drawString("m/s", 275, 11);

        tft.setTextColor(TFT_NAVY, TFT_WHITE);
        tft.setTextDatum(TR_DATUM);                   // Sağa yaslı hizalama
        tft.drawString(flow_buffer, 223, 60, FONT6);  // Sayıyı ekrana yazdır
        draw_sigma(18, 128, TFT_NAVY);
        tft.drawString(total_buffer_main_screen, 223, 128, FONT4);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString("SW : 2.0", 35, 220, FONT2);
        tft.drawString("HW : 4.1", 107, 220, FONT2);
        tft.drawString("MSG :", 195, 220, FONT2);
        tft.drawString("NORMAL", 235, 220, FONT2);

        bar_graph_new(19, 166, percentage_bar, TFT_NAVY, TFT_CYAN, TFT_DARKGREY);

        // Akış birimi oku
        // Total unit ve flow unit oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x07, &flow_unit_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        // Flow Unit
        tft.setTextDatum(TL_DATUM);  // Sağa yaslı hizalama
        tft.setFreeFont(FSS12);
        if (flow_unit_value == 2) {
          tft.drawString("L/h", 235, 77, FONT4);
          decpoint = 0;
        } else if (flow_unit_value == 5) {
          tft.drawString("m3/h", 235, 77, FONT4);
          decpoint = 2;
        }

        // Total unit oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x0B, &total_unit_value);  // Registerdan istenilen değeri oku
        delay(time_after_communication);                                        // iki modbus haberleşmesi arası beklenecek min süre

        tft.setFreeFont(FSS9);
        if (total_unit_value == 7) {
          tft.drawString("m3", 238, 128, FONT4);
        } else if (total_unit_value == 3) {
          tft.drawString("L", 238, 128, FONT4);
        }
      }

      if (button_state == press_up) {
        button_state = idle;
        // opening_page = true;


        break;

      } else if (button_state == press_down) {
        button_state = idle;
        // opening_page = true;


        break;

      } else if (button_state == press_enter) {
        button_state = idle;
        opening_page = true;

        if (password_validity_time > 120) screen_switch = password_screen;  // password geçerlilik süresi devam ediyorsa şifre ekranını atla
        else {
          screen_switch = settings;  // devam etmiyorsa şifre ekranına git
        }
      } else if (button_state == press_esc) {
        button_state = idle;

        screen_total_choice++;

        if (screen_total_choice >= 3) screen_total_choice = 0;
        EEPROM.writeUShort(screen_total_choice_address, screen_total_choice);
        EEPROM.commit();  // kaydet
      }

      // Belirlenen sürede ekran verilerini güncelle
      if (time_for_main_sreens >= screen_refresh_time_value) {
        time_for_main_sreens = 0;  // saniye sıfırla

        static uint8_t previous_percentage;                                 // anlık akış yüzdesi
        static int32_t differantiel = 0;                                    // total ileri akış - total geri akış ham değer
        static float differantiel_float = 0;                                // total ileri akış - total geri akış float değeri
        uint8_t number_of_digit = 0;                                        // ekrana yazılacak bamasak sayısı
        static uint8_t previous_flow_digits, previous_differantiel_digits;  // ekrana yazılacak bamasak sayısı
        uint16_t pos_flow = 215, pos_differantiel = 250;                    // Anlık akış değeri başlangıç x koordinatı
        uint8_t character_counter = 0;                                      // bamasak hesaplama sayıcısı

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // Anlık akış değerini oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x1010, &flow);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        modbus_slave.write_to_holding_registers(holdingRegisters, flow, flow_address);

        // Anlık akış değerine göre ekranda nokta kaydır
        if (decpoint == 1) {
          if (flow < 10 && flow > -10) decpoint = 1;
          else if (flow < 100 && flow > -100) decpoint = 1;
          else if (flow < 1000 && flow > -1000) decpoint = 1;
          else if (flow < 10000 && flow > -10000) decpoint = 1;
          else if (flow < 100000 && flow > -100000) decpoint = 1;
          else if (flow < 1000000 && flow > -1000000) decpoint = 0;
        } else if (decpoint == 2) {
          if (flow < 10 && flow > -10) decpoint = 2;
          else if (flow < 100 && flow > -100) decpoint = 2;
          else if (flow < 1000 && flow > -1000) decpoint = 2;
          else if (flow < 10000 && flow > -10000) decpoint = 2;
          else if (flow < 100000 && flow > -100000) decpoint = 1;
          else if (flow < 1000000 && flow > -1000000) decpoint = 0;
        } else if (decpoint == 3) {
          if (flow < 10 && flow > -10) decpoint = 3;
          else if (flow < 100 && flow > -100) decpoint = 3;
          else if (flow < 1000 && flow > -1000) decpoint = 3;
          else if (flow < 10000 && flow > -10000) decpoint = 2;
          else if (flow < 100000 && flow > -100000) decpoint = 1;
          else if (flow < 1000000 && flow > -1000000) decpoint = 0;
        } else if (decpoint == 4) {
          if (flow < 10 && flow > -10) decpoint = 4;
          else if (flow < 100 && flow > -100) decpoint = 4;
          else if (flow < 1000 && flow > -1000) decpoint = 3;
          else if (flow < 10000 && flow > -10000) decpoint = 2;
          else if (flow < 100000 && flow > -100000) decpoint = 1;
          else if (flow < 1000000 && flow > -1000000) decpoint = 0;
        }

        if (decpoint == 0) {
          sprintf(flow_buffer, "%.0f", flow);
        } else if (decpoint == 1) {
          sprintf(flow_buffer, "%.1f", flow);
        } else if (decpoint == 2) {
          sprintf(flow_buffer, "%.2f", flow);
        } else if (decpoint == 3) {
          sprintf(flow_buffer, "%.3f", flow);
        } else if (decpoint == 4) {
          sprintf(flow_buffer, "%.4f", flow);
        }

        tft.setTextDatum(TR_DATUM);  // Sağa yaslı hizalama
        tft.setTextColor(TFT_NAVY, TFT_WHITE);
        tft.setTextPadding(2000);
        tft.drawString(flow_buffer, 223, 60, FONT6);
        tft.setTextPadding(0);

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        tft.setTextDatum(TL_DATUM);  // Sağa yaslı hizalama

        // if (theme_color == dark_theme) {
        //   tft.setTextColor(TFT_SILVER, TFT_BLACK);
        // } else {
        //   tft.setTextColor(TFT_BLACK, TFT_CREAM);
        // }

        // 5 saniyede bir alarmları kontrol et
        if (alarm_time_counter >= 5) {

          alarm_time_counter = 0;

          alarm_state = 0;

          uint16_t alarm_state_temporary = 0;

          // Empty pipe alarm
          modbus_master.read_or_write(1, READ_HOLDING, 0x1024, &alarm_state_temporary);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          alarm_state = alarm_state_temporary;
          alarm_state_temporary = 0;  // sonraki işlem için içini temizle

          // System alarm
          modbus_master.read_or_write(1, READ_HOLDING, 0x1025, &alarm_state_temporary);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          alarm_state = alarm_state |= alarm_state_temporary << 1;
          alarm_state_temporary = 0;  // sonraki işlem için içini temizle

          // Upper limit alarm
          modbus_master.read_or_write(1, READ_HOLDING, 0x1022, &alarm_state_temporary);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          alarm_state = alarm_state |= alarm_state_temporary << 2;
          alarm_state_temporary = 0;  // sonraki işlem için içini temizle

          // Lower limit alarm
          modbus_master.read_or_write(1, READ_HOLDING, 0x1023, &alarm_state_temporary);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          alarm_state = alarm_state |= alarm_state_temporary << 3;
          alarm_state_temporary = 0;  // sonraki işlem için içini temizle

          // Level upper limit alarm
          modbus_master.read_or_write(1, READ_HOLDING, 0x102C, &alarm_state_temporary);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          alarm_state = alarm_state |= alarm_state_temporary << 4;
          alarm_state_temporary = 0;  // sonraki işlem için içini temizle

          // Level lower limit alarm
          modbus_master.read_or_write(1, READ_HOLDING, 0x102D, &alarm_state_temporary);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          alarm_state = alarm_state |= alarm_state_temporary << 5;
        }

        // alarm durumunu ekrana bas
        if (alarm_state == 0) {
          if (previous_alarm_state != alarm_state || page_change == true) {
            tft.setTextColor(TFT_NAVY, TFT_WHITE);
            tft.drawString("NORMAL      ", 235, 220, FONT2);
            previous_alarm_state = alarm_state;  // önceki Alarm değerini koru
          }

        } else {  // Alarm yanıp sönme animasyonu için
          alarm_animation = !alarm_animation;

          if (theme_color == dark_theme) {
            if (alarm_animation) {
              tft.setTextColor(TFT_SILVER, TFT_BLACK);
            } else {
              tft.setTextColor(TFT_BLACK, TFT_SILVER);
            }
          } else {
            if (alarm_animation) {
              tft.setTextColor(TFT_WHITE, TFT_NAVY);
            } else {
              tft.setTextColor(TFT_NAVY, TFT_WHITE);
            }
          }

          bool alarm_counter_flag = false;
          while (alarm_counter < 6) {
            if ((alarm_state & (1 << 0)) && alarm_counter == 0) {  // alarm registerının 0. bitini kontrol et
              tft.drawString("ERR - 001", 235, 220, FONT2);        // Empt Pipe Alarm - Boş boru alarmı
              alarm_counter++;
              alarm_counter_flag = true;
              break;
            } else if ((alarm_state & (1 << 1)) && alarm_counter == 1) {  // alarm registerının 1. bitini kontrol et
              tft.drawString("ERR - 002", 235, 220, FONT2);               // SYS Alarm (isimlendirilecek)
              alarm_counter++;
              alarm_counter_flag = true;
              break;
            } else if ((alarm_state & (1 << 2)) && alarm_counter == 2) {  // alarm registerının 2. bitini kontrol et
              tft.drawString("ERR - 003", 235, 220, FONT2);               // High Flow Alarm - Yüksek akış alarmı
              alarm_counter++;
              alarm_counter_flag = true;
              break;
            } else if ((alarm_state & (1 << 3)) && alarm_counter == 3) {  // alarm registerının 3. bitini kontrol et
              tft.drawString("ERR - 004", 235, 220, FONT2);               // Low Flow Alarm - Düşük akış alarmı
              alarm_counter++;
              alarm_counter_flag = true;
              break;
            } else if ((alarm_state & (1 << 4)) && alarm_counter == 4) {  // alarm registerının 4. bitini kontrol et
              tft.drawString("ERR - 005", 235, 220, FONT2);               // Excitation Drive Alarm - DRV (isimlendirilecek)
              alarm_counter++;
              alarm_counter_flag = true;
              break;
            } else if ((alarm_state & (1 << 5)) && alarm_counter == 5) {  // alarm registerının 5. bitini kontrol et
              tft.drawString("ERR - 006", 235, 220, FONT2);               // Eeprom Alarm (isimlendirilecek)
              alarm_counter++;
              alarm_counter_flag = true;
              break;
            } else if (alarm_counter_flag == false) {
              alarm_counter = -1;
              alarm_counter_flag = true;
            }
            alarm_counter++;
          }

          if (alarm_counter >= 5) alarm_counter = 0;

          previous_alarm_state = alarm_state;  // önceki Alarm değerini koru
        }
        if (theme_color == dark_theme) {
          tft.setTextColor(TFT_WHITE, TFT_BLACK);
        } else {
          tft.setTextColor(TFT_NAVY, TFT_WHITE);
        }


        // Alarm durumuna göre dijital çıkışları organize et
        if (alarm_state & (1 << 0)) {  // alarm registerının 0. bitini kontrol et
          // Empt Pipe Alarm - Boş boru alarmı
          if (D_out_2_alarm_state == 1) {
            digitalWrite(pulse_pin, 1);
          }
          if (D_out_3_alarm_state == 1) {
            digitalWrite(relay_pin, 1);
          }
        } else {
          // Empt Pipe Alarm - Boş boru alarmı
          if (D_out_2_alarm_state == 1) {
            digitalWrite(pulse_pin, 0);
          }
          if (D_out_3_alarm_state == 1) {
            digitalWrite(relay_pin, 0);
          }
        }
        if (alarm_state & (1 << 1)) {  // alarm registerının 1. bitini kontrol et
          // SYS Alarm (isimlendirilecek)
          if (D_out_2_alarm_state == 2) {
            digitalWrite(pulse_pin, 1);
          }
          if (D_out_3_alarm_state == 2) {
            digitalWrite(relay_pin, 1);
          }
        } else {
          // SYS Alarm (isimlendirilecek)
          if (D_out_2_alarm_state == 2) {
            digitalWrite(pulse_pin, 0);
          }
          if (D_out_3_alarm_state == 2) {
            digitalWrite(relay_pin, 0);
          }
        }
        if (alarm_state & (1 << 2)) {  // alarm registerının 2. bitini kontrol et
          // High Flow Alarm - Yüksek akış alarmı
          if (D_out_2_alarm_state == 4) {
            digitalWrite(pulse_pin, 1);
          }
          if (D_out_3_alarm_state == 4) {
            digitalWrite(relay_pin, 1);
          }
        } else {
          // High Flow Alarm - Yüksek akış alarmı
          if (D_out_2_alarm_state == 4) {
            digitalWrite(pulse_pin, 0);
          }
          if (D_out_3_alarm_state == 4) {
            digitalWrite(relay_pin, 0);
          }
        }
        if (alarm_state & (1 << 3)) {  // alarm registerının 3. bitini kontrol et
          // Low Flow Alarm - Düşük akış alarmı
          if (D_out_2_alarm_state == 8) {
            digitalWrite(pulse_pin, 1);
          }
          if (D_out_3_alarm_state == 8) {
            digitalWrite(relay_pin, 1);
          }
        } else {
          // Low Flow Alarm - Düşük akış alarmı
          if (D_out_2_alarm_state == 8) {
            digitalWrite(pulse_pin, 0);
          }
          if (D_out_3_alarm_state == 8) {
            digitalWrite(relay_pin, 0);
          }
        }
        if (D_out_2_alarm_state == 16) {
          if (flow < 0) {
            digitalWrite(pulse_pin, 1);
          } else {
            digitalWrite(pulse_pin, 0);
          }
        }
        if (D_out_3_alarm_state == 16) {
          if (flow < 0) {
            digitalWrite(relay_pin, 1);
          } else {
            digitalWrite(relay_pin, 0);
          }
        }

        tft.setTextDatum(TR_DATUM);  // Sağa yaslı hizalama
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // TOTAL artı değeri bas
        modbus_master.read_or_write(1, READ_HOLDING, 0x1018, &total_positive);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre
        total_positive = total_positive - total_eeprom_positive;

        // TOTAL eksi değerini oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x101C, &total_negative);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre
        total_negative = total_negative - total_eeprom_negative;

        // TOTAL fark değeri bas
        total_differential = total_positive - total_negative;

        modbus_slave.write_to_holding_registers(holdingRegisters, total_differential, total_differential_address);
        modbus_slave.write_to_holding_registers(holdingRegisters, total_positive, total_positive_address);  // holding registera yaz
        modbus_slave.write_to_holding_registers(holdingRegisters, total_negative, total_negative_address);  // holding registera yaz

        tft.setFreeFont(FSS12);
        if (screen_total_choice == 0) {
          tft.fillRect(35, 125, 17, 30, TFT_WHITE);
          tft.drawString("d", 49, 131);
          sprintf(total_buffer_main_screen, "%d", total_differential);
        } else if (screen_total_choice == 1) {
          tft.fillRect(35, 125, 17, 30, TFT_WHITE);
          tft.drawString("+", 48, 126);
          sprintf(total_buffer_main_screen, "%u", total_positive);
        } else if (screen_total_choice == 2) {
          tft.fillRect(35, 125, 17, 30, TFT_WHITE);
          tft.drawString("-", 44, 128);
          sprintf(total_buffer_main_screen, "%u", total_negative);
        }

        tft.setTextPadding(170);
        tft.drawString(total_buffer_main_screen, 223, 128, FONT4);
        tft.setTextPadding(0);
        tft.setTextDatum(TL_DATUM);  // Sağa yaslı hizalama


        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // level değerini oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x102A, &level);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        modbus_slave.write_to_holding_registers(holdingRegisters, level, level_address);

        dac_ma_value = mapFloat(mA_out, 4, 21, lower_limit_mA, upper_limit_mA);  // 4 - 20 mA arasını dac için 0 - 255 e uyarla
        MCP.setValue(dac_ma_value);

        // mA değerini bas
        sprintf(level_buffer, "%.0f", level);

        tft.setFreeFont(FSS9);
        tft.setTextDatum(TR_DATUM);  // Sağa yaslı hizalama
        tft.setTextColor(TFT_WHITE, TFT_BLUEE);
        tft.setTextPadding(65);
        tft.drawString(level_buffer, 85, 6, FONT4);
        tft.setTextPadding(0);
        tft.setTextDatum(TL_DATUM);  // Sağa yaslı hizalama

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // Velocity değerini oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x1012, &flow_rate);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        modbus_slave.write_to_holding_registers(holdingRegisters, flow_rate, flow_rate_address);

        sprintf(velocity_buffer, "%.3f", flow_rate);

        // Akış hızı değerini bas
        tft.setFreeFont(FSS9);
        tft.setTextDatum(TR_DATUM);  // Sağa yaslı hizalama
        tft.setTextPadding(100);
        tft.drawString(velocity_buffer, 270, 6, FONT4);
        tft.setTextPadding(0);
        tft.setTextDatum(TL_DATUM);  // Sağa yaslı hizalama

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // yüzde değerini oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x1014, &percentage);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        percentage_bar = percentage;
        if (percentage_bar < 0) percentage_bar = percentage_bar * -1;  // eksi ile barı dolduramayacağı için pozitif yapılıyor
        if (percentage_bar > 100) percentage_bar = 100;                // Bar ın taşmaması için limitle

        // Bar ın kırpışmasını azaltmak için anlık akış yüzdesinde değişim yoksa tekrar bastırma
        if (previous_percentage != percentage_bar || page_change == true) {
          bar_graph_new(19, 166, percentage_bar, TFT_NAVY, TFT_CYAN, TFT_DARKGREY);
        }
        previous_percentage = percentage_bar;

        percentage_V = percentage;
        if (percentage_V > 100) percentage_V = 100;  // voltaj çıkışı 0 - 10v arasında olduğu için min max değerler sınırlandırılmıştır
        else if (percentage_V < -100) percentage_V = -100;
        // V değerini akışın yüzdesini baz alarak hesapla ve seçilen biçime göre çıkış ver
        if (analog_out_3_type == v_0_10) {                         // Akım çıkışı 4 - 20 mA seçildiyse
          if (percentage_V < 0) percentage_V = percentage_V * -1;  // Ters yöndeki akışı hesaplamalar için pozitife dönüştür
          if (percentage_V > 100) percentage_V = 100;              // 20.50 mA da sınırlaması için
          V = percentage_V * 10 / 100;
        } else if (analog_out_3_type == v_0_5_10) {  // Akım çıkışı 4 - 12 - 20 mA seçildiyse
          V = (percentage_V * 5 / 100) + 5;
        }

        dac_v_value = mapFloat(V, 0, 10, lower_limit_VDC, upper_limit_VDC);  // 0 - 10 VDC arasını dac için 0 - 255 e uyarla
        // dacWrite(DAC_2_PIN_V, dac_v_value);

        page_change = false;  // sayfa değişimi olmadığını göstermek için
      }
      break;

    case password_screen:

      if (opening_page == true) {
        opening_page = false;

        tft.fillScreen(TFT_BLACK);

        tft.setTextColor(TFT_ORANGE, TFT_BLACK);
        tft.setFreeFont(FSS18);
        if (language == English) {
          tft.drawString(english[0], 81, 40);  // Password
          tft.setFreeFont(FSS9);
          tft.drawString(english[1], 69, 190);  // Please Enter Password
        } else if (language == Turkish) {
          tft.drawString(turkish[0], 118, 40);  // Sifre
          tft.setFreeFont(FSS9);
          tft.drawString(turkish[1], 115, 190);  // Lutfen Sifre girin
        }

        tft.drawWideLine(270, 95, 50, 95, 3, TFT_SILVER, TFT_SILVER);  // çizgi

        tft.pushImage(70, 120, 40, 40, locckk);  // kilit ikonu

        draw_char(0, 115, 121, TFT_BLACK, TFT_WHITE);
        draw_char(0, 148, 121, TFT_WHITE, TFT_BLACK);
        draw_char(0, 181, 121, TFT_WHITE, TFT_BLACK);
        draw_char(0, 214, 121, TFT_WHITE, TFT_BLACK);

        digit = 0;

        memset(number, 0, sizeof(number));
      }

      // Şifre ekranında işlem yapılmadıysa 30 Sn sonra ana ekrana dön
      if (second_for_menu > 30) {
        second_for_menu = 0;  // saniye sıfırla
        screen_switch = main_screen;
        opening_page = true;
      }

      if (button_state == press_up) {
        button_state = idle;
        if (digit == 0) {
          number[0]++;
          if (number[0] > 9) number[0] = 0;
          draw_char(number[0], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 1) {
          number[1]++;
          if (number[1] > 9) number[1] = 0;
          draw_char(number[1], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 2) {
          number[2]++;
          if (number[2] > 9) number[2] = 0;
          draw_char(number[2], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 3) {
          number[3]++;
          if (number[3] > 9) number[3] = 0;
          draw_char(number[3], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        }


      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
        if (digit > 3) digit = 0;

        if (digit == 0) {
          draw_char(number[3], 115 + 3 * 33, 121, TFT_WHITE, TFT_BLACK);
          draw_char(number[0], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 1) {
          draw_char(number[0], 115 + (digit - 1) * 33, 121, TFT_WHITE, TFT_BLACK);
          draw_char(number[1], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 2) {
          draw_char(number[1], 115 + (digit - 1) * 33, 121, TFT_WHITE, TFT_BLACK);
          draw_char(number[2], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 3) {
          draw_char(number[2], 115 + (digit - 1) * 33, 121, TFT_WHITE, TFT_BLACK);
          draw_char(number[3], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        }



      } else if (button_state == press_enter) {
        button_state = idle;
        cursor = 6;           // menu ekranında kursor basic_settings den başlayacak
        previous_cursor = 6;  // menu ekranında kursor basic_settings den başlayacak

        uint16_t password = number[0] * 1000 + number[1] * 100 + number[2] * 10 + number[3];  // girilen şifreyi password değişkenine ata
        if (main_password == password || master_password == password) {
          tft.setFreeFont(FSS18);
          tft.setTextColor(TFT_DARKGREEN, TFT_BLACK);
          tft.fillRect(20, 190, 300, 20, TFT_BLACK);
          if (language == English) {
            tft.drawString(english[0], 81, 40);  // password
            tft.setFreeFont(FSSB9);
            tft.drawString(english[2], 130, 190);  // done

          } else if (language == Turkish) {
            tft.drawString(turkish[0], 118, 40);  // Sifre
            tft.setFreeFont(FSSB9);
            tft.drawString(turkish[2], 130, 190);  // onaylandı
          }
          tft.setFreeFont(FSS18);
          delay(1500);
          screen_switch = settings;
          opening_page = true;
          password_validity_time = 0;  // şifrenin 2 dk geçerlilik süresi başladı
        } else {

          tft.fillRect(80, 190, 200, 20, TFT_BLACK);
          tft.setTextColor(TFT_RED, TFT_BLACK);
          tft.setFreeFont(FSS9);
          if (language == English) {
            tft.drawString(english[3], 45, 190);  // Wrong Password !  Try Again
            tft.setFreeFont(FSS18);
            tft.drawString(english[0], 81, 40);  // Password
            delay(1500);
            tft.setTextColor(TFT_ORANGE, TFT_BLACK);
            tft.drawString(english[0], 81, 40);  // Password
          } else if (language == Turkish) {
            tft.drawString(turkish[3], 5, 190);  // Şifre yanlış Tekrar deneyin
            tft.setFreeFont(FSS18);
            tft.drawString(turkish[0], 118, 40);  // Sifre
            delay(1500);
            tft.setTextColor(TFT_ORANGE, TFT_BLACK);
            tft.drawString(turkish[0], 118, 40);  // Sifre
          }
        }



      } else if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = main_screen;
      }
      break;

    case settings:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = main_screen;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(icons_main, 75, left_aligned, 4, 5, 6, 7, 8, 9, 10, basic_settings, information);

      break;

    case basic_settings:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = settings;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(basic_settings_icon, 4, 75, left_aligned, 154, 15, 16, 17, quick_setup, sensor_size);

      break;

    case languages:

      if (opening_page == true) {
        opening_page = false;
        tft.fillScreen(0xc658);
        centered_language_bar(high_light);

        if (cursor == english_language) {
          turkish_bar(high_light);
          english_bar(low_light);
        } else if (cursor == turkish_language) {
          english_bar(high_light);
          turkish_bar(low_light);
        }



        // seçilen dilin yeşil tik ini çiz
        if (language == English) {
          draw_tick(105, 50, TFT_DARKGREEN);
        } else {
          draw_tick(105, 83, TFT_DARKGREEN);
        }
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = basic_settings;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;
        opening_page = true;

        //  tik işaretini sil
        if (language == English) {
          draw_tick(105, 50, TFT_WHITE);
        } else {
          draw_tick(105, 83, TFT_WHITE);
        }

        // imleç ile seçili dili register a yaz
        if (cursor == english_language) language_state = English;
        else language_state = Turkish;

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x40, &protect_password);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x31, &language_state);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        // yazma doğrulandıysa dili değiştir
        if (language_state == English) language = English;
        else language = Turkish;


        // seçilen dilin yeşil tik ini çiz
        if (language == English) {
          draw_tick(105, 50, TFT_DARKGREEN);
        } else {
          draw_tick(105, 83, TFT_DARKGREEN);
        }

        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > turkish_language) cursor = english_language;  // kursoru baştaysa sona döndür
      if (cursor < english_language) cursor = turkish_language;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == english_language) {
          turkish_bar(high_light);
          english_bar(low_light);
        } else if (cursor == turkish_language) {
          english_bar(high_light);
          turkish_bar(low_light);
        }
        previous_cursor = cursor;

        if (language == English) {
          draw_tick(105, 50, TFT_DARKGREEN);
        } else {
          draw_tick(105, 83, TFT_DARKGREEN);
        }
      }

      break;

    case flow_parameters:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = basic_settings;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(basic_settings_icon, 16, 75, left_aligned, 109, 33, 36, 37, _units, flow_direction);

      break;

    case _units:

      if (opening_page == true) {
        opening_page = false;
        cursor = flow_unit;
        tft.fillScreen(0xc658);
        total_unit_bar(high_light);
        centered_units_bar(high_light);
        flow_unit_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = flow_parameters;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > total_unit) cursor = flow_unit;  // kursoru baştaysa sona döndür
      if (cursor < flow_unit) cursor = total_unit;  // kursoru sondaysa başa döndür


      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == flow_unit) {
          total_unit_bar(high_light);
          flow_unit_bar(low_light);
        } else if (cursor == total_unit) {
          flow_unit_bar(high_light);
          total_unit_bar(low_light);
        }
        previous_cursor = cursor;
      }

      break;

    case flow_unit:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = _units;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x40, &protect_password);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre


        if (cursor == m3_h) {
          total_unit_value = 5;
          pulse_unit = 1;
          tick_location = 1;
        } else if (cursor == L_h) {
          total_unit_value = 2;
          pulse_unit = 0;
          tick_location = 2;
        }


        modbus_master.read_or_write(1, WRITE_SINGLE, 0x10, &pulse_unit);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x07, &total_unit_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        tick_location = 0;
        previous_tick_location = tick_location;
        cursor = m3_h;

        modbus_master.read_or_write(1, READ_HOLDING, 0x0007, &total_unit_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        if (total_unit_value == 5) tick_location = 1;
        else if (total_unit_value == 2) tick_location = 2;
      }

      bar_select(basic_settings_icon, 32, 140, middle_aligned, 214, 215, m3_h, L_h);

      break;

    case total_unit:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = _units;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (cursor == m3_) {
          total_unit_value = 7;
          tick_location = 1;
        } else if (cursor == L_) {
          total_unit_value = 3;
          tick_location = 2;
        }

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x000B, &total_unit_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre


      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        tick_location = 0;
        previous_tick_location = tick_location;
        cursor = m3_;

        modbus_master.read_or_write(1, READ_HOLDING, 0x000B, &total_unit_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        if (total_unit_value == 7) tick_location = 1;
        else if (total_unit_value == 3) tick_location = 2;
      }

      bar_select(basic_settings_icon, 110, 140, middle_aligned, 214, 215, m3_, L_);

      break;

    case flow_range:
    case _flow_range:

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;

        modbus_master.read_or_write(1, READ_HOLDING, 0x06, &uint16_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre        number_entry_opening_page(uint16_value, positive, decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz

        // Akış birimi oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x07, &flow_unit_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre


        if (flow_unit_value == 5) {  // m3
          fixed_digit = 5;
          read_or_write_number = (float)uint16_value / 10.0f;                             // Okunan değeri basamaklara ayrılıp ekrana yazılması için global değişkene at
          number_entry_opening_page(read_or_write_number, positive, non_decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz
          tft.setFreeFont(FSS9);
          tft.drawString("m3/h", 239, 122);
          tft.setFreeFont(FSS12);
          tft.drawString("= 0 - 6553.5", 127, 190);
        } else if (flow_unit_value == 2) {  // L
          fixed_digit = 50;
          number_entry_opening_page(uint16_value, positive, decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz
          tft.setFreeFont(FSS9);
          tft.drawString("L/h", 239, 122);
          tft.setFreeFont(FSS12);
          tft.drawString("= 0 - 65535", 127, 190);
        }

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[33], 90, 28);  // Flow Range
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 48, 190);  // Range
        } else if (language == Turkish) {
          tft.drawString(turkish[33], 60, 28);  // ölçme Araligi
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 57, 190);  // Aralik
        }
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;

        if (previous_screen_switch == quick_setup) {
          screen_switch = quick_setup;
          previous_screen_switch = 0;
        } else {
          screen_switch = flow_parameters;
        }

      } else if (button_state == press_enter) {
        button_state = idle;

        number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

        if (flow_unit_value == 5) {                                           // m3
          if (read_or_write_number >= 0 && read_or_write_number <= 6553.5) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

            modbus_master.read_or_write(1, WRITE_SINGLE, 0x40, &protect_password);
            delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

            uint16_value = (uint16_t)(read_or_write_number * 10.0f);
            modbus_master.read_or_write(1, WRITE_SINGLE, 0x06, &uint16_value);
            delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

            tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
            tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
            tft.setFreeFont(FSSB9);
            if (language == English) {
              tft.drawString(english[2], 135, 162);  // done !
              tft.setTextColor(TFT_GREY, TFT_WHITE);
              tft.setFreeFont(FSS12);
              tft.drawString(english[69], 48, 190);  // Range
              tft.drawString("= 0 - 6553.5", 127, 190);
            } else if (language == Turkish) {
              tft.drawString(turkish[2], 112, 162);  // onaylandi !
              tft.setTextColor(TFT_GREY, TFT_WHITE);
              tft.setFreeFont(FSS12);
              tft.drawString(turkish[69], 57, 190);  // Aralik
              tft.drawString("= 0 - 6553.5", 127, 190);
            }
            delay(1000);
            tft.drawString("                            ", 75, 162);  // done !
          } else {                                                    // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap
            tft.setTextColor(TFT_RED, TFT_WHITE);
            tft.setFreeFont(FSSB9);
            if (language == English) {
              tft.drawString(english[73], 105, 162);  // out of range
              tft.setFreeFont(FSS12);
              tft.drawString(english[69], 48, 190);  // Range
              tft.drawString("= 0 - 6553.5", 127, 190);
              tft.setTextColor(TFT_GREY, TFT_WHITE);
            } else if (language == Turkish) {
              tft.drawString(turkish[73], 95, 162);  // araligin disinda
              tft.setFreeFont(FSS12);
              tft.drawString(turkish[69], 57, 190);  // Aralik
              tft.drawString("= 0 - 6553.5", 127, 190);
              tft.setTextColor(TFT_GREY, TFT_WHITE);
            }
            delay(1000);
            tft.drawString("                            ", 75, 162);  // done !
          }
        } else if (flow_unit_value == 2) {                                   // L
          if (read_or_write_number >= 0 && read_or_write_number <= 65535) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

            modbus_master.read_or_write(1, WRITE_SINGLE, 0x40, &protect_password);
            delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

            uint16_value = (uint16_t)read_or_write_number;
            modbus_master.read_or_write(1, WRITE_SINGLE, 0x0006, &uint16_value);
            delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

            tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
            tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
            tft.setFreeFont(FSSB9);
            if (language == English) {
              tft.drawString(english[2], 135, 162);  // done !
              tft.setTextColor(TFT_GREY, TFT_WHITE);
              tft.setFreeFont(FSS12);
              tft.drawString(english[69], 48, 190);  // Range
              tft.drawString("= 0 - 65535", 127, 190);
            } else if (language == Turkish) {
              tft.drawString(turkish[2], 112, 162);  // onaylandi !
              tft.setTextColor(TFT_GREY, TFT_WHITE);
              tft.setFreeFont(FSS12);
              tft.drawString(turkish[69], 57, 190);  // Aralik
              tft.drawString("= 0 - 65535", 127, 190);
            }
            delay(1000);
            tft.drawString("                            ", 75, 162);  // done !
          } else {                                                    // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap
            tft.setTextColor(TFT_RED, TFT_WHITE);
            tft.setFreeFont(FSSB9);
            if (language == English) {
              tft.drawString(english[73], 105, 162);  // out of range
              tft.setFreeFont(FSS12);
              tft.drawString(english[69], 48, 190);  // Range
              tft.drawString("= 0 - 65535", 127, 190);
              tft.setTextColor(TFT_GREY, TFT_WHITE);
            } else if (language == Turkish) {
              tft.drawString(turkish[73], 95, 162);  // araligin disinda
              tft.setFreeFont(FSS12);
              tft.drawString(turkish[69], 57, 190);  // Aralik
              tft.drawString("= 0 - 65535", 127, 190);
              tft.setTextColor(TFT_GREY, TFT_WHITE);
            }
            delay(1000);
            tft.drawString("                            ", 75, 162);  // done !
          }
        }




      } else if (button_state == press_up) {
        button_state = idle;

        increase_digit_number();
      } else if (button_state == press_down) {
        button_state = idle;

        digit++;

        if (flow_unit_value == 5) {  // m3 için
          if (digit == 6) digit = 7;
        }
      }
      cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir

      break;

    case flow_cut_off:

      static uint16_t flow_cut_off_enable;

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;

        modbus_master.read_or_write(1, READ_HOLDING, 0x09, &uint16_value);  // Registerdan istenilen değeri oku
        delay(time_after_communication);                                    // iki modbus haberleşmesi arası beklenecek min süre

        // Akış birimi oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x07, &flow_unit_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (flow_unit_value == 5) {  // m3
          fixed_digit = 5;
          read_or_write_number = (float)uint16_value / 10.0f;                             // Okunan değeri basamaklara ayrılıp ekrana yazılması için global değişkene at
          number_entry_opening_page(read_or_write_number, positive, non_decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz
          tft.setFreeFont(FSS12);
          tft.drawString("/ m3", 241, 117);
          tft.drawString("=  0 - 3276.7", 130, 190);
          digit = 2;
        } else if (flow_unit_value == 2) {  // L
          fixed_digit = 50;
          number_entry_opening_page(uint16_value, positive, decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz
          tft.setFreeFont(FSS12);
          tft.drawString("/ L", 241, 117);
          tft.drawString("=  0 - 32767", 130, 190);
          digit = 3;
        }

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[36], 80, 14);  // flow cut-off
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 50, 190);  // Range
        } else if (language == Turkish) {
          tft.drawString(turkish[36], 80, 14);
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 70, 190);
        }

        modbus_master.read_or_write(1, READ_HOLDING, 0x0A, &flow_cut_off_enable);  // Registerdan istenilen değeri oku
        delay(time_after_communication);                                           // iki modbus haberleşmesi arası beklenecek min süre

        tft.setTextColor(TFT_GREY, TFT_WHITE);
        tft.setFreeFont(FSS9);
        tft.drawString(english[76], 46, 40);   // active
        tft.drawString(english[77], 213, 40);  // passive

        tft.drawWideLine(275, 70, 45, 70, 4, TFT_RED, TFT_RED);  // uzun kırmızı çizgi

        tft.drawRect(57, 14, 20, 20, TFT_DARKGREEN);  // soldaki içi boş kare
        tft.drawRect(231, 14, 20, 20, TFT_RED);       // sağdaki içi boş kare

        if (flow_cut_off_enable == 0) {  // sensitivity_ kapalı
          tft.fillRect(232, 15, 18, 18, TFT_RED);
        } else if (flow_cut_off_enable == 1) {  // sensitivity_ açık
          tft.fillRect(58, 15, 18, 18, TFT_DARKGREEN);
        }
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = flow_parameters;
        fixed_digit = 50;
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        if (flow_cut_off_enable == 1) {

          if (digit == 8) {
            flow_cut_off_enable = 0;
            tft.fillRect(58, 15, 18, 18, TFT_WHITE);
            tft.fillRect(232, 15, 18, 18, TFT_RED);

            modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
            delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

            modbus_master.read_or_write(1, WRITE_SINGLE, 0x0A, &flow_cut_off_enable);  // Registerdan istenilen değeri oku
            delay(time_after_communication);                                           // iki modbus haberleşmesi arası beklenecek min süre
          } else {

            number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

            if (flow_unit_value == 5) {                                            // m3
              if (read_or_write_number >= 0 && read_or_write_number <= 3276.7f) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
                delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

                uint16_value = (uint16_t)(read_or_write_number * 10.0f);

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x09, &uint16_value);  // Registerdan istenilen değeri oku
                delay(time_after_communication);                                    // iki modbus haberleşmesi arası beklenecek min süre


                tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
                tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[2], 135, 162);  // done !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 3276.7", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[2], 112, 162);  // onaylandi !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 70, 190);  // Aralik
                  tft.drawString("=  0 - 3276.7", 130, 190);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap
                tft.setTextColor(TFT_RED, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[73], 105, 162);  // out of range
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 3276.7", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[73], 95, 162);  // araligin disinda
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 70, 190);  // Aralik
                  tft.drawString("=  0 - 3276.7", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              }
            } else if (flow_unit_value == 2) {                                   // L
              if (read_or_write_number >= 0 && read_or_write_number <= 32767) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
                delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

                uint16_value = (uint16_t)read_or_write_number;

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x09, &uint16_value);  // Registerdan istenilen değeri oku
                delay(time_after_communication);                                    // iki modbus haberleşmesi arası beklenecek min süre


                tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
                tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[2], 135, 162);  // done !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 32767", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[2], 112, 162);  // onaylandi !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 70, 190);  // Aralik
                  tft.drawString("=  0 - 32767", 130, 190);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap
                tft.setTextColor(TFT_RED, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[73], 105, 162);  // out of range
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 32767", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[73], 95, 162);  // araligin disinda
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 70, 190);  // Aralik
                  tft.drawString("=  0 - 32767", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              }
            }
          }
        } else {
          flow_cut_off_enable = 1;
          tft.fillRect(232, 15, 18, 18, TFT_WHITE);
          tft.fillRect(58, 15, 18, 18, TFT_DARKGREEN);

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0A, &flow_cut_off_enable);  // Registerdan istenilen değeri oku
          delay(time_after_communication);                                           // iki modbus haberleşmesi arası beklenecek min süre

          if (flow_unit_value == 5) {  // m3 için
            digit = 2;
          } else digit = 3;  // L için
        }

      } else if (button_state == press_up) {
        button_state = idle;

        if (flow_cut_off_enable == 1) {
          increase_digit_number();
        }
      } else if (button_state == press_down) {
        button_state = idle;
        if (flow_cut_off_enable == 1) {
          digit++;

          if (digit > 8) {

            if (flow_unit_value == 5) {  // m3 için
              digit = 2;
            } else digit = 3;  // L için
            tft.fillRect(232, 15, 18, 18, TFT_WHITE);
          }

          if (digit == 8) {
            tft.drawWideLine(57 + digit - 1 * 25, 147, 34 + digit * 25, 147, 4, TFT_WHITE, TFT_WHITE);  // imleç kutucuklara geçince önceki pozisyonunun kalıntısını sil
            half_second = previous_half_second;
          }

          if (flow_unit_value == 5) {  // m3 için
            if (digit == 6) digit = 7;
          }
        }
      }

      if (flow_cut_off_enable == 0) {  // kutu animasyonları

        if (half_second != previous_half_second) {
          if (green_rectengular == true) {  // red line çizilimi
            tft.fillRect(58, 15, 18, 18, TFT_WHITE);
          } else {
            tft.fillRect(58, 15, 18, 18, TFT_DARKGREEN);
          }
          green_rectengular = !green_rectengular;
          previous_half_second = half_second;
        }
      } else {
        if (digit == 8) {
          if (half_second != previous_half_second) {
            if (green_rectengular == true) {  // red line çizilimi
              tft.fillRect(232, 15, 18, 18, TFT_WHITE);
            } else {
              tft.fillRect(232, 15, 18, 18, TFT_RED);
            }
            green_rectengular = !green_rectengular;
            previous_half_second = half_second;
          }
        } else {
          cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir
        }
      }

      break;

    case flow_direction:

      static uint16_t flow_direction_register;

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = flow_parameters;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (cursor == forward) {
          flow_direction_register = 0;
          tick_location = 1;
        } else if (cursor == reverse) {
          flow_direction_register = 1;
          tick_location = 2;
        }

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x0005, &flow_direction_register);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre


      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        tick_location = 0;
        cursor = forward;

        modbus_master.read_or_write(1, READ_HOLDING, 0x0005, &flow_direction_register);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        if (flow_direction_register == 0) tick_location = 1;
        else if (flow_direction_register == 1) tick_location = 2;
      }

      bar_select(basic_settings_icon, 37, 140, middle_aligned, 80, 81, forward, reverse);

      break;

    case sensor_size:
    case _sensor_size:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;

        if (previous_screen_switch == quick_setup) {
          screen_switch = quick_setup;
          previous_screen_switch = 0;
        } else {
          screen_switch = basic_settings;
        }

        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        uint16_value = cursor - size_32;  // anakarta register hazırlandı yazmak için

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x0004, &uint16_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (uint16_value >= 0 && uint16_value <= 5) tick_location = uint16_value + 1;
        else if (uint16_value >= 6 && uint16_value <= 11) tick_location = uint16_value - 5;
        else if (uint16_value >= 12 && uint16_value <= 17) tick_location = uint16_value - 11;
        else if (uint16_value >= 18 && uint16_value <= 23) tick_location = uint16_value - 17;
        else if (uint16_value >= 24 && uint16_value <= 29) tick_location = uint16_value - 23;
        else if (uint16_value >= 30 && uint16_value <= 35) tick_location = uint16_value - 29;
        else if (uint16_value >= 36 && uint16_value <= 41) tick_location = uint16_value - 35;
        else if (uint16_value >= 42 && uint16_value <= 47) tick_location = uint16_value - 41;
        else if (uint16_value >= 48 && uint16_value <= 53) tick_location = uint16_value - 47;

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        previous_cursor = 100;
        first_text = true;
        modbus_master.read_or_write(1, READ_HOLDING, 0x0004, &uint16_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre
        if (uint16_value >= 0 && uint16_value <= 5) cursor = size_32;
        else if (uint16_value >= 6 && uint16_value <= 11) cursor = size_70;
        else if (uint16_value >= 12 && uint16_value <= 17) cursor = size_100;
        else if (uint16_value >= 18 && uint16_value <= 23) cursor = size_320;
        else if (uint16_value >= 24 && uint16_value <= 29) cursor = size_600;
        else if (uint16_value >= 30 && uint16_value <= 35) cursor = size_900;
        else if (uint16_value >= 36 && uint16_value <= 41) cursor = size_1400;
        else if (uint16_value >= 42 && uint16_value <= 47) cursor = size_2000;
        else if (uint16_value >= 48 && uint16_value <= 53) cursor = size_2600;
      }

      if (cursor < size_32) {
        opening_page = true;
        first_text = true;
        cursor = size_2600;
      } else if (cursor > size_4000) {
        opening_page = true;
        first_text = true;
        cursor = size_32;
      } else if (cursor == size_65 && previous_cursor == size_70) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_70 && previous_cursor == size_65) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_95 && previous_cursor == size_100) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_100 && previous_cursor == size_95) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_300 && previous_cursor == size_320) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_320 && previous_cursor == size_300) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_550 && previous_cursor == size_600) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_600 && previous_cursor == size_550) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_850 && previous_cursor == size_900) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_900 && previous_cursor == size_850) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_1300 && previous_cursor == size_1400) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_1400 && previous_cursor == size_1300) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_1900 && previous_cursor == size_2000) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_2000 && previous_cursor == size_1900) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_2500 && previous_cursor == size_2600) {
        opening_page = true;
        first_text = true;
      } else if (cursor == size_2600 && previous_cursor == size_2500) {
        opening_page = true;
        first_text = true;
      }

      if (cursor >= size_32 && cursor <= size_65) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value + 1;
        }

        bar_select(basic_settings_icon, 17, 130, middle_aligned, 160, 161, 162, 163, 164, 165, size_32, size_65);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("1/9", 260, 13);
        }

      } else if (cursor >= size_70 && cursor <= size_95) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value - 5;
        }

        bar_select(basic_settings_icon, 17, 130, middle_aligned, 166, 167, 168, 169, 170, 171, size_70, size_95);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("2/9", 260, 13);
        }

      } else if (cursor >= size_100 && cursor <= size_300) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value - 11;
        }

        bar_select(basic_settings_icon, 17, 130, middle_aligned, 172, 173, 174, 175, 176, 177, size_100, size_300);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("3/9", 260, 13);
        }

      } else if (cursor >= size_320 && cursor <= size_550) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value - 17;
        }

        bar_select(basic_settings_icon, 17, 130, middle_aligned, 178, 179, 180, 181, 182, 183, size_320, size_550);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("4/9", 260, 13);
        }

      } else if (cursor >= size_600 && cursor <= size_850) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value - 23;
        }

        bar_select(basic_settings_icon, 17, 130, middle_aligned, 184, 185, 186, 187, 188, 189, size_600, size_850);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("5/9", 260, 13);
        }

      } else if (cursor >= size_900 && cursor <= size_1300) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value - 29;
        }

        bar_select(basic_settings_icon, 17, 130, middle_aligned, 190, 191, 192, 193, 194, 195, size_900, size_1300);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("6/9", 260, 13);
        }

      } else if (cursor >= size_1400 && cursor <= size_1900) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value - 35;
        }

        bar_select(basic_settings_icon, 17, 130, middle_aligned, 196, 197, 198, 199, 200, 201, size_1400, size_1900);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("7/9", 260, 13);
        }

      } else if (cursor >= size_2000 && cursor <= size_2500) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value - 41;
        }

        bar_select(basic_settings_icon, 17, 130, middle_aligned, 202, 203, 204, 205, 206, 207, size_2000, size_2500);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("8/9", 260, 13);
        }

      } else if (cursor >= size_2600 && cursor <= size_4000) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value - 47;
        }

        bar_select(basic_settings_icon, 17, 130, middle_aligned, 208, 209, 210, 211, 212, 213, size_2600, size_4000);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("9/9", 260, 13);
        }
      }

      break;

    case quick_setup:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = basic_settings;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        previous_screen_switch = quick_setup;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(basic_settings_icon, 154, 75, left_aligned, 17, 33, 108, 148, _sensor_size, _pulse_factor);

      break;

    case advanced_settings:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = settings;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(advanced_setting_icon, 5, 75, left_aligned, 108, 112, 21, 20, k_factor, change_password);

      break;

    case change_password:

      static bool change_password_key = false;

      if (opening_page == true) {
        opening_page = false;

        tft.fillScreen(TFT_BLACK);

        tft.setTextColor(TFT_ORANGE, TFT_BLACK);
        tft.setFreeFont(FSS18);
        if (language == English) {
          tft.drawString(english[0], 81, 40);  // Password
          tft.setFreeFont(FSS9);
          tft.drawString(english[92], 45, 190);  // Please Enter Valid Password
        } else if (language == Turkish) {
          tft.drawString(turkish[0], 125, 40);  // Sifre
          tft.setFreeFont(FSS9);
          tft.drawString(turkish[92], 65, 190);  // Lutfen Sifre Gecerli Girin
        }

        tft.drawWideLine(270, 95, 50, 95, 3, TFT_SILVER, TFT_SILVER);  // çizgi

        tft.pushImage(70, 120, 40, 40, locckk);  // kilit ikonu

        draw_char(0, 115, 121, TFT_BLACK, TFT_WHITE);
        draw_char(0, 148, 121, TFT_WHITE, TFT_BLACK);
        draw_char(0, 181, 121, TFT_WHITE, TFT_BLACK);
        draw_char(0, 214, 121, TFT_WHITE, TFT_BLACK);

        digit = 0;

        memset(number, 0, sizeof(number));
      }

      if (button_state == press_up) {
        button_state = idle;
        if (digit == 0) {
          number[0]++;
          if (number[0] > 9) number[0] = 0;
          draw_char(number[0], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 1) {
          number[1]++;
          if (number[1] > 9) number[1] = 0;
          draw_char(number[1], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 2) {
          number[2]++;
          if (number[2] > 9) number[2] = 0;
          draw_char(number[2], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 3) {
          number[3]++;
          if (number[3] > 9) number[3] = 0;
          draw_char(number[3], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        }


      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
        if (digit > 3) digit = 0;

        if (digit == 0) {
          draw_char(number[3], 115 + 3 * 33, 121, TFT_WHITE, TFT_BLACK);
          draw_char(number[0], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 1) {
          draw_char(number[0], 115 + (digit - 1) * 33, 121, TFT_WHITE, TFT_BLACK);
          draw_char(number[1], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 2) {
          draw_char(number[1], 115 + (digit - 1) * 33, 121, TFT_WHITE, TFT_BLACK);
          draw_char(number[2], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        } else if (digit == 3) {
          draw_char(number[2], 115 + (digit - 1) * 33, 121, TFT_WHITE, TFT_BLACK);
          draw_char(number[3], 115 + digit * 33, 121, TFT_BLACK, TFT_WHITE);
        }



      } else if (button_state == press_enter) {
        button_state = idle;

        uint16_t password = number[0] * 1000 + number[1] * 100 + number[2] * 10 + number[3];  // girilen şifreyi password değişkenine ata

        if (change_password_key == false) {
          if (main_password == password || master_password == password) {

            change_password_key = true;

            draw_char(0, 115, 121, TFT_BLACK, TFT_WHITE);
            draw_char(0, 148, 121, TFT_WHITE, TFT_BLACK);
            draw_char(0, 181, 121, TFT_WHITE, TFT_BLACK);
            draw_char(0, 214, 121, TFT_WHITE, TFT_BLACK);
            digit = 0;

            memset(number, 0, sizeof(number));
            tft.fillRect(20, 190, 300, 20, TFT_BLACK);

            tft.setTextColor(TFT_DARKGREEN, TFT_BLACK);
            tft.setFreeFont(FSS9);
            if (language == English) {
              tft.drawString(english[2], 145, 190);  // done
              delay(1500);
              tft.setTextColor(TFT_ORANGE, TFT_BLACK);
              tft.drawString(english[93], 50, 190);  // please enter new password
            } else if (language == Turkish) {
              tft.drawString(turkish[2], 120, 190);  // onaylandı
              delay(1500);
              tft.setTextColor(TFT_ORANGE, TFT_BLACK);
              tft.drawString(turkish[93], 75, 190);  // lütfen yeni şifreyi girin
            }

          } else {

            tft.fillRect(80, 190, 200, 20, TFT_BLACK);
            tft.setTextColor(TFT_RED, TFT_BLACK);
            tft.setFreeFont(FSS9);
            if (language == English) {
              tft.drawString(english[3], 45, 190);  // Wrong Password !  Try Again
              tft.setFreeFont(FSS18);
              tft.drawString(english[0], 81, 40);  // Password
              delay(1500);
              tft.setTextColor(TFT_ORANGE, TFT_BLACK);
              tft.drawString(english[0], 81, 40);  // Password
            } else if (language == Turkish) {
              tft.drawString(turkish[3], 45, 190);  // Şifre yanlış Tekrar deneyin
              tft.setFreeFont(FSS18);
              tft.drawString(turkish[0], 125, 40);  // Sifre
              delay(1500);
              tft.setTextColor(TFT_ORANGE, TFT_BLACK);
              tft.drawString(turkish[0], 125, 40);  // Sifre
            }
          }
        } else {
          change_password_key = false;

          EEPROM.writeUShort(main_password_address, password);  // Değiştirilen şifreyi eeproma yazmaya hazırla

          EEPROM.commit();  // kaydet

          main_password = password;

          tft.fillRect(20, 190, 300, 20, TFT_BLACK);
          tft.setTextColor(TFT_DARKGREEN, TFT_BLACK);
          tft.setFreeFont(FSS9);
          if (language == English) {
            tft.drawString(english[94], 50, 190);  // the password was chanced
          } else if (language == Turkish) {
            tft.drawString(turkish[94], 105, 190);  // sifre degistildi
          }
          delay(2000);
          screen_switch = advanced_settings;

          opening_page = true;
        }

      } else if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        change_password_key = false;
        screen_switch = advanced_settings;
      }

      break;

    case reset:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = advanced_settings;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(advanced_setting_icon, 21, 75, left_aligned, 96, 97, total_forward_reset, total_reverse_reset);

      break;

    case total_forward_reset:

      if (opening_page == true) {
        opening_page = false;
        cursor = no;
        tft.fillScreen(0xc658);
        yes_bar(high_light);
        centered_total_forward_reset_bar(high_light);
        no_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = reset;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;
        opening_page = true;

        if (cursor == yes) {

          modbus_master.read_or_write(1, READ_HOLDING, 0x1018, &total_eeprom_positive);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          EEPROM.writeULong(total_eeprom_positive_address, total_eeprom_positive);  // eeproma yazmaya hazırla

          EEPROM.commit();  // eeproma kaydet

          tft.setTextColor(TFT_DARKGREEN, 0xc658);
          tft.setFreeFont(FSSB12);

          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 100, 160);  // onaylandi !
          }
          delay(1500);
        }
        screen_switch = reset;  // ayarlar sayfasına git

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > yes) cursor = no;  // kursoru baştaysa sona döndür
      if (cursor < no) cursor = yes;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == no) {
          yes_bar(high_light);
          no_bar(low_light);
        } else if (cursor == yes) {
          no_bar(high_light);
          yes_bar(low_light);
        }
        previous_cursor = cursor;
      }

      break;

    case total_reverse_reset:

      if (opening_page == true) {
        opening_page = false;
        cursor = no;
        tft.fillScreen(0xc658);
        yes_bar(high_light);
        centered_total_reverse_reset_bar(high_light);
        no_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = reset;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;
        opening_page = true;

        if (cursor == yes) {

          modbus_master.read_or_write(1, READ_HOLDING, 0x101C, &total_eeprom_negative);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          EEPROM.writeULong(total_eeprom_negative_address, total_eeprom_negative);  // eeproma yazmaya hazırla

          EEPROM.commit();  // eeproma kaydet

          tft.setTextColor(TFT_DARKGREEN, 0xc658);
          tft.setFreeFont(FSSB12);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 100, 160);  // onaylandi !
          }
          delay(1500);
        }
        screen_switch = reset;  // ayarlar sayfasına git

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > yes) cursor = no;  // kursoru baştaysa sona döndür
      if (cursor < no) cursor = yes;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == no) {
          yes_bar(high_light);
          no_bar(low_light);
        } else if (cursor == yes) {
          no_bar(high_light);
          yes_bar(low_light);
        }
        previous_cursor = cursor;
      }
      break;



    case meter_factor:

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;
        fixed_digit = 2;

        modbus_master.read_or_write(1, READ_HOLDING, 0x1D, &uint16_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        read_or_write_number = (float)uint16_value / 10000.0f;

        number_entry_opening_page(read_or_write_number, positive, non_decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz

        digit = 2;

        if (language == English) {
          tft.setFreeFont(FSS18);
          tft.drawString(english[112], 63, 20);  // Meter Factor
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 50, 185);  // Range
        } else if (language == Turkish) {
          tft.setFreeFont(FSS18);
          tft.drawString(turkish[112], 50, 20);
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 50, 185);
        }
        tft.drawString("=  0 - 5.9999", 130, 185);
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;
        fixed_digit = 50;

        opening_page = true;
        screen_switch = advanced_settings;
      } else if (button_state == press_enter) {
        button_state = idle;

        number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

        if (read_or_write_number >= 0 && read_or_write_number <= 5.9999) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          uint16_value = (uint16_t)(read_or_write_number * 10000.0f);

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x1D, &uint16_value);
          delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 50, 185);  // Range
            tft.drawString("=  0 - 5.9999", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 50, 185);  // Aralik
            tft.drawString("=  0 - 5.9999", 130, 185);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını 1 sn kırmızı yap
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_RED, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 50, 185);  // Range
            tft.drawString("=  0 - 5.9999", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 95, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 50, 185);  // Aralik
            tft.drawString("=  0 - 5.9999", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }


      } else if (button_state == press_up) {
        button_state = idle;

        increase_digit_number();
      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
        if (digit == 3) digit = 4;
        if (digit == 8) digit = 2;  // cursorun başa dönmesi için
      }
      cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir

      break;

    case k_factor:
    case _k_factor:

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;
        fixed_digit = 2;

        modbus_master.read_or_write(1, READ_HOLDING, 0x1C, &uint16_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        read_or_write_number = (float)uint16_value / 10000.0f;

        number_entry_opening_page(read_or_write_number, positive, non_decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz

        digit = 2;

        if (language == English) {
          tft.setFreeFont(FSS18);
          tft.drawString(english[108], 95, 20);  // K Factor
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 50, 185);  // Range
        } else if (language == Turkish) {
          tft.setFreeFont(FSS18);
          tft.drawString(turkish[108], 85, 20);
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 50, 185);
        }
        tft.drawString("=  0 - 5.9999", 130, 185);
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;
        fixed_digit = 50;

        opening_page = true;

        if (previous_screen_switch == quick_setup) {
          screen_switch = quick_setup;
          previous_screen_switch = 0;
        } else {
          screen_switch = advanced_settings;
        }

      } else if (button_state == press_enter) {
        button_state = idle;

        number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

        if (read_or_write_number >= 0 && read_or_write_number <= 5.9999) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          uint16_value = (uint16_t)(read_or_write_number * 10000.0f);

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x1C, &uint16_value);
          delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 50, 185);  // Range
            tft.drawString("=  0 - 5.9999", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 50, 185);  // Aralik
            tft.drawString("=  0 - 5.9999", 130, 185);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını 1 sn kırmızı yap
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_RED, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 50, 185);  // Range
            tft.drawString("=  0 - 5.9999", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 95, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 50, 185);  // Aralik
            tft.drawString("=  0 - 5.9999", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }


      } else if (button_state == press_up) {
        button_state = idle;

        increase_digit_number();
      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
        if (digit == 3) digit = 4;
        if (digit == 8) digit = 2;  // cursorun başa dönmesi için
      }
      cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir

      break;

    case output:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = settings;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(output_icon, 6, 75, left_aligned, 24, 25, 130, analog_output, alarms);

      break;

    case analog_output:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = output;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(output_icon, 24, 75, left_aligned, 82, 101, analog_out_1_mA, analog_out_3_VDC);

      break;

    case analog_out_1_mA:

      if (opening_page == true) {
        opening_page = false;
        cursor = function_analog_out_2_mA;
        tft.fillScreen(0xc658);
        output_type_bar(high_light);
        test_mode_bar(high_light);
        output_calibration_bar(high_light);
        centered_analog_output_2_mA_bar(high_light);
        function_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = analog_output;
      } else if (button_state == press_enter) {
        button_state = idle;

        screen_switch = cursor;
        opening_page = true;  // Analog output 1 için function seçeneğine gitme

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > output_calibration_analog_out_2_mA) cursor = function_analog_out_2_mA;  // kursoru baştaysa sona döndür
      if (cursor < function_analog_out_2_mA) cursor = output_calibration_analog_out_2_mA;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == function_analog_out_2_mA) {
          if (previous_cursor == output_calibration_analog_out_2_mA) {
            output_calibration_bar(high_light);
          } else if (previous_cursor == output_type_analog_out_2_mA) {
            output_type_bar(high_light);
          }
          function_bar(low_light);
        } else if (cursor == output_type_analog_out_2_mA) {
          if (previous_cursor == function_analog_out_2_mA) {
            function_bar(high_light);
          } else if (previous_cursor == test_mode_analog_out_2_mA) {
            test_mode_bar(high_light);
          }
          output_type_bar(low_light);
        } else if (cursor == test_mode_analog_out_2_mA) {
          if (previous_cursor == output_type_analog_out_2_mA) {
            output_type_bar(high_light);
          } else if (previous_cursor == output_calibration_analog_out_2_mA) {
            output_calibration_bar(high_light);
          }
          test_mode_bar(low_light);
        } else if (cursor == output_calibration_analog_out_2_mA) {
          if (previous_cursor == test_mode_analog_out_2_mA) {
            test_mode_bar(high_light);
          } else if (previous_cursor == function_analog_out_2_mA) {
            function_bar(high_light);
          }
          output_calibration_bar(low_light);
        }
        previous_cursor = cursor;
      }

      break;

    case analog_out_3_VDC:

      if (opening_page == true) {
        opening_page = false;
        cursor = function_analog_out_3_VDC;
        tft.fillScreen(0xc658);
        output_type_bar(high_light);
        test_mode_bar(high_light);
        output_calibration_bar(high_light);
        centered_analog_output_3_VDC_bar(high_light);
        function_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = analog_output;
      } else if (button_state == press_enter) {
        button_state = idle;

        screen_switch = cursor;
        opening_page = true;  // Analog output 1 için function seçeneğine gitme

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > output_calibration_analog_out_3_VDC) cursor = function_analog_out_3_VDC;  // kursoru baştaysa sona döndür
      if (cursor < function_analog_out_3_VDC) cursor = output_calibration_analog_out_3_VDC;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == function_analog_out_3_VDC) {
          if (previous_cursor == output_calibration_analog_out_3_VDC) {
            output_calibration_bar(high_light);
          } else if (previous_cursor == output_type_analog_out_3_VDC) {
            output_type_bar(high_light);
          }
          function_bar(low_light);
        } else if (cursor == output_type_analog_out_3_VDC) {
          if (previous_cursor == function_analog_out_3_VDC) {
            function_bar(high_light);
          } else if (previous_cursor == test_mode_analog_out_3_VDC) {
            test_mode_bar(high_light);
          }
          output_type_bar(low_light);
        } else if (cursor == test_mode_analog_out_3_VDC) {
          if (previous_cursor == output_type_analog_out_3_VDC) {
            output_type_bar(high_light);
          } else if (previous_cursor == output_calibration_analog_out_3_VDC) {
            output_calibration_bar(high_light);
          }
          test_mode_bar(low_light);
        } else if (cursor == output_calibration_analog_out_3_VDC) {
          if (previous_cursor == test_mode_analog_out_3_VDC) {
            test_mode_bar(high_light);
          } else if (previous_cursor == function_analog_out_3_VDC) {
            function_bar(high_light);
          }
          output_calibration_bar(low_light);
        }
        previous_cursor = cursor;
      }

      break;

    case function_analog_out_2_mA:

      if (opening_page == true) {
        opening_page = false;
        cursor = flow_type;
        tft.fillScreen(0xc658);
        temperature_type_bar(high_light);
        conductivity_type_bar(high_light);
        centered_funciton_bar(high_light);
        flow_type_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = analog_out_1_mA;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > conductivity_type) cursor = flow_type;  // kursoru baştaysa sona döndür
      if (cursor < flow_type) cursor = conductivity_type;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == flow_type) {
          if (previous_cursor == conductivity_type) {
            conductivity_type_bar(high_light);
          } else if (previous_cursor == temperature_type) {
            temperature_type_bar(high_light);
          }
          flow_type_bar(low_light);
        } else if (cursor == temperature_type) {
          if (previous_cursor == flow_type) {
            flow_type_bar(high_light);
          } else if (previous_cursor == conductivity_type) {
            conductivity_type_bar(high_light);
          }
          temperature_type_bar(low_light);
        } else if (cursor == conductivity_type) {
          if (previous_cursor == temperature_type) {
            temperature_type_bar(high_light);
          } else if (previous_cursor == flow_type) {
            flow_type_bar(high_light);
          }
          conductivity_type_bar(low_light);
        }
        previous_cursor = cursor;
        draw_tick(76, 50, TFT_DARKGREEN);  // tick işareti
      }

      break;

    case function_analog_out_3_VDC:

      if (opening_page == true) {
        opening_page = false;
        cursor = flow_type;
        tft.fillScreen(0xc658);
        temperature_type_bar(high_light);
        conductivity_type_bar(high_light);
        centered_funciton_bar(high_light);
        flow_type_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = analog_out_3_VDC;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > conductivity_type) cursor = flow_type;  // kursoru baştaysa sona döndür
      if (cursor < flow_type) cursor = conductivity_type;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == flow_type) {
          if (previous_cursor == conductivity_type) {
            conductivity_type_bar(high_light);
          } else if (previous_cursor == temperature_type) {
            temperature_type_bar(high_light);
          }
          flow_type_bar(low_light);
        } else if (cursor == temperature_type) {
          if (previous_cursor == flow_type) {
            flow_type_bar(high_light);
          } else if (previous_cursor == conductivity_type) {
            conductivity_type_bar(high_light);
          }
          temperature_type_bar(low_light);
        } else if (cursor == conductivity_type) {
          if (previous_cursor == temperature_type) {
            temperature_type_bar(high_light);
          } else if (previous_cursor == flow_type) {
            flow_type_bar(high_light);
          }
          conductivity_type_bar(low_light);
        }
        previous_cursor = cursor;
        draw_tick(76, 50, TFT_DARKGREEN);  // tick işareti
      }

      break;

    case output_type_analog_out_2_mA:

      if (opening_page == true) {
        opening_page = false;
        cursor = _ma_4_20;
        tft.fillScreen(0xc658);
        _ma_4_12_20_bar(high_light);
        centered_output_type_bar(high_light);
        _ma_4_20_bar(low_light);

        analog_out_2_type = EEPROM.readUShort(analog_out_2_type_address);

        write_tick_for_analog_out_2_type();
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = analog_out_1_mA;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick_for_analog_out_2_type();

        if (cursor == _ma_4_20) analog_out_2_type = _ma_4_20;
        else if (cursor == _ma_4_12_20) analog_out_2_type = _ma_4_12_20;

        EEPROM.writeUShort(analog_out_2_type_address, analog_out_2_type);
        EEPROM.commit();  // kaydet

        write_tick_for_analog_out_2_type();

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > _ma_4_12_20) cursor = _ma_4_20;  // kursoru baştaysa sona döndür
      if (cursor < _ma_4_20) cursor = _ma_4_12_20;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == _ma_4_20) {
          _ma_4_12_20_bar(high_light);
          _ma_4_20_bar(low_light);
        } else if (cursor == _ma_4_12_20) {
          _ma_4_20_bar(high_light);
          _ma_4_12_20_bar(low_light);
        }
        previous_cursor = cursor;
        write_tick_for_analog_out_2_type();
      }

      break;

    case output_type_analog_out_3_VDC:

      if (opening_page == true) {
        opening_page = false;
        cursor = v_0_10;
        tft.fillScreen(0xc658);
        v_0_5_10_bar(high_light);
        centered_output_type_bar(high_light);
        v_0_10_bar(low_light);

        analog_out_3_type = EEPROM.readUShort(analog_out_3_type_address);

        write_tick_for_analog_out_3_type();
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = analog_out_3_VDC;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick_for_analog_out_3_type();

        if (cursor == v_0_10) analog_out_3_type = v_0_10;
        else if (cursor == v_0_5_10) analog_out_3_type = v_0_5_10;

        EEPROM.writeUShort(analog_out_3_type_address, analog_out_3_type);
        EEPROM.commit();  // kaydet

        write_tick_for_analog_out_3_type();
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > v_0_5_10) cursor = v_0_10;  // kursoru baştaysa sona döndür
      if (cursor < v_0_10) cursor = v_0_5_10;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == v_0_10) {
          v_0_5_10_bar(high_light);
          v_0_10_bar(low_light);
        } else if (cursor == v_0_5_10) {
          v_0_10_bar(high_light);
          v_0_5_10_bar(low_light);
        }
        previous_cursor = cursor;
        write_tick_for_analog_out_3_type();
      }

      break;

    case test_mode_analog_out_2_mA:

      if (opening_page == true) {
        opening_page = false;
        cursor = ma_4;
        tft.fillScreen(0xc658);
        ma_20_bar(high_light);
        ma_12_bar(high_light);
        centered_test_mode_bar(high_light);
        ma_4_bar(low_light);

        tft.setFreeFont(FSSB9);
        tft.setTextColor(TFT_BLACK, 0xc658);
        if (language == English) {
          tft.drawString(english[88], 80, 162);  // only for flowmeter
        } else {
          tft.drawString(turkish[88], 76, 162);  // yalnız akis icindir
        }

        analog_out_2_type = ma_4;  // tick işareti için
        MCP.setValue(lower_limit_mA);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        analog_out_2_type = EEPROM.readUShort(analog_out_2_type_address);  // test modundan çıkarken hangi çıkış tipi seçiliyse onunla devam etmesi için
        screen_switch = analog_out_1_mA;                                   // ayarlar sayfasına git

      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick_for_analog_out_2_test();

        if (cursor == ma_4) {
          analog_out_2_type = ma_4;      // tick işareti için
          MCP.setValue(lower_limit_mA);  // 4 ma değeri
        } else if (cursor == ma_12) {
          analog_out_2_type = ma_12;  // tick işareti için
          MCP.setValue(1468);         // 12 ma değeri
        } else if (cursor == ma_20) {
          analog_out_2_type = ma_20;  // tick işareti için
          MCP.setValue(2445);         // 20 ma değeri
        }

        write_tick_for_analog_out_2_test();

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > ma_20) cursor = ma_4;  // kursoru baştaysa sona döndür
      if (cursor < ma_4) cursor = ma_20;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == ma_4) {
          if (previous_cursor == ma_20) {
            ma_20_bar(high_light);
          } else if (previous_cursor == ma_12) {
            ma_12_bar(high_light);
          }
          ma_4_bar(low_light);
        } else if (cursor == ma_12) {
          if (previous_cursor == ma_4) {
            ma_4_bar(high_light);
          } else if (previous_cursor == ma_20) {
            ma_20_bar(high_light);
          }
          ma_12_bar(low_light);
        } else if (cursor == ma_20) {
          if (previous_cursor == ma_12) {
            ma_12_bar(high_light);
          } else if (previous_cursor == ma_4) {
            ma_4_bar(high_light);
          }
          ma_20_bar(low_light);
        }
        previous_cursor = cursor;
        write_tick_for_analog_out_2_test();
      }

      break;

    case test_mode_analog_out_3_VDC:

      if (opening_page == true) {
        opening_page = false;
        cursor = v_0_10;
        tft.fillScreen(0xc658);
        v_5_bar(high_light);
        centered_output_type_bar(high_light);
        v_10_bar(low_light);

        // dacWrite(DAC_2_PIN_V, upper_limit_VDC / 2);  // 5 v değeri
        analog_out_3_type = v_0_10;
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = analog_out_3_VDC;  // ayarlar sayfasına git
        analog_out_3_type = EEPROM.readUShort(analog_out_3_type_address);
      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick_for_analog_out_3_type();

        if (cursor == v_0_10) analog_out_3_type = v_0_10;
        else if (cursor == v_0_5_10) analog_out_3_type = v_0_5_10;

        if (cursor == v_0_10) {
          analog_out_3_type = v_0_10;                  // tick işareti için
          // dacWrite(DAC_2_PIN_V, upper_limit_VDC / 2);  // 5 v değeri
        } else if (cursor == v_0_5_10) {
          analog_out_3_type = v_0_5_10;            // tick işareti için
          // dacWrite(DAC_2_PIN_V, upper_limit_VDC);  // 10 v değeri
        }

        write_tick_for_analog_out_3_type();
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > v_0_5_10) cursor = v_0_10;  // kursoru baştaysa sona döndür
      if (cursor < v_0_10) cursor = v_0_5_10;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == v_0_10) {
          v_10_bar(high_light);
          v_5_bar(low_light);
        } else if (cursor == v_0_5_10) {
          v_5_bar(high_light);
          v_10_bar(low_light);
        }
        previous_cursor = cursor;
        write_tick_for_analog_out_3_type();
      }

      break;

    case output_calibration_analog_out_2_mA:

      if (opening_page == true) {
        opening_page = false;
        cursor = set_lower_analog_out_2_mA;
        tft.fillScreen(0xc658);
        adjust_20_ma_bar(high_light);
        centered_output_calibration_bar(high_light);
        adjust_4_ma_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = analog_out_1_mA;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > set_upper_analog_out_2_mA) cursor = set_lower_analog_out_2_mA;  // kursoru baştaysa sona döndür
      if (cursor < set_lower_analog_out_2_mA) cursor = set_upper_analog_out_2_mA;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == set_lower_analog_out_2_mA) {
          adjust_20_ma_bar(high_light);
          adjust_4_ma_bar(low_light);
        } else if (cursor == set_upper_analog_out_2_mA) {
          adjust_4_ma_bar(high_light);
          adjust_20_ma_bar(low_light);
        }
        previous_cursor = cursor;
      }

      break;

    case output_calibration_analog_out_3_VDC:

      if (opening_page == true) {
        opening_page = false;
        cursor = set_lower_analog_out_3_VDC;
        tft.fillScreen(0xc658);
        adjust_10_V_bar(high_light);
        centered_output_calibration_bar(high_light);
        adjust_0_V_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = analog_out_3_VDC;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > set_upper_analog_out_3_VDC) cursor = set_lower_analog_out_3_VDC;  // kursoru baştaysa sona döndür
      if (cursor < set_lower_analog_out_3_VDC) cursor = set_upper_analog_out_3_VDC;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == set_lower_analog_out_3_VDC) {
          adjust_10_V_bar(high_light);
          adjust_0_V_bar(low_light);
        } else if (cursor == set_upper_analog_out_3_VDC) {
          adjust_0_V_bar(high_light);
          adjust_10_V_bar(low_light);
        }
        previous_cursor = cursor;
      }

      break;

    case set_lower_analog_out_2_mA:

      if (opening_page == true) {
        opening_page = false;

        calibration_value = lower_limit_mA;

        MCP.setValue(calibration_value);

        tft.fillScreen(0xc658);
        tft.fillRoundRect(20, 4, 280, 232, 15, TFT_WHITE);       // yumuşak köşeli beyaz arka plan
        tft.drawWideLine(260, 70, 60, 70, 4, TFT_RED, TFT_RED);  // uzun kırmızı çizgi

        tft.setTextColor(TFT_GREY, TFT_WHITE);
        tft.setFreeFont(FSS24);

        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 200, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[104], 90, 28);  // adjust 4 ma
          tft.setFreeFont(FSS12);
        } else if (language == Turkish) {
          tft.drawString(turkish[104], 88, 28);  // ayarla 4 ma
          tft.setFreeFont(FSS12);
        }
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;
        screen_switch = output_calibration_analog_out_2_mA;
      } else if (button_state == press_enter) {
        button_state = idle;

        lower_limit_mA = calibration_value;

        EEPROM.writeUShort(lower_limit_mA_address, lower_limit_mA);

        EEPROM.commit();  // kaydet

        tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
        tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
        tft.setFreeFont(FSSB9);
        if (language == English) {
          tft.drawString(english[2], 135, 162);  // done !
          tft.setTextColor(TFT_GREY, TFT_WHITE);
          tft.setFreeFont(FSS12);
        } else if (language == Turkish) {
          tft.drawString(turkish[2], 112, 162);  // onaylandi !
          tft.setTextColor(TFT_GREY, TFT_WHITE);
          tft.setFreeFont(FSS12);
        }
        delay(1000);
        tft.drawString("                            ", 75, 162);

      } else if (button_state == press_up) {
        button_state = idle;

        calibration_value++;
        if (calibration_value == 65535) calibration_value = 0;

        MCP.setValue(calibration_value);

        tft.setFreeFont(FSS24);
        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 200, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama

      } else if (button_state == press_down) {
        button_state = idle;

        calibration_value--;
        if (calibration_value == 65535) calibration_value = 0;

        MCP.setValue(calibration_value);

        tft.setFreeFont(FSS24);
        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 200, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama
      }

      break;

    case set_upper_analog_out_2_mA:

      if (opening_page == true) {
        opening_page = false;

        calibration_value = upper_limit_mA;

        MCP.setValue(calibration_value);

        tft.fillScreen(0xc658);
        tft.fillRoundRect(20, 4, 280, 232, 15, TFT_WHITE);       // yumuşak köşeli beyaz arka plan
        tft.drawWideLine(260, 70, 60, 70, 4, TFT_RED, TFT_RED);  // uzun kırmızı çizgi

        tft.setTextColor(TFT_GREY, TFT_WHITE);
        tft.setFreeFont(FSS24);

        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 216, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[105], 90, 28);  // adjust 4 ma
          tft.setFreeFont(FSS12);
        } else if (language == Turkish) {
          tft.drawString(turkish[105], 86, 28);  // ayarla 20 ma
          tft.setFreeFont(FSS12);
        }
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;
        screen_switch = output_calibration_analog_out_2_mA;
      } else if (button_state == press_enter) {
        button_state = idle;

        upper_limit_mA = calibration_value;

        EEPROM.writeUShort(upper_limit_mA_address, upper_limit_mA);

        EEPROM.commit();  // kaydet

        tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
        tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
        tft.setFreeFont(FSSB9);
        if (language == English) {
          tft.drawString(english[2], 135, 162);  // done !
          tft.setTextColor(TFT_GREY, TFT_WHITE);
          tft.setFreeFont(FSS12);
        } else if (language == Turkish) {
          tft.drawString(turkish[2], 112, 162);  // onaylandi !
          tft.setTextColor(TFT_GREY, TFT_WHITE);
          tft.setFreeFont(FSS12);
        }
        delay(1000);
        tft.drawString("                            ", 75, 162);

      } else if (button_state == press_up) {
        button_state = idle;

        calibration_value++;
        if (calibration_value == 65535) calibration_value = 0;

        MCP.setValue(calibration_value);

        tft.setFreeFont(FSS24);
        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 216, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama

      } else if (button_state == press_down) {
        button_state = idle;

        calibration_value--;
        if (calibration_value == 65535) calibration_value = 0;

        MCP.setValue(calibration_value);

        tft.setFreeFont(FSS24);
        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 216, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama
      }

      break;

    case set_lower_analog_out_3_VDC:

      if (opening_page == true) {
        opening_page = false;

        calibration_value = lower_limit_VDC;

        // dacWrite(DAC_2_PIN_V, calibration_value);

        tft.fillScreen(0xc658);
        tft.fillRoundRect(20, 4, 280, 232, 15, TFT_WHITE);       // yumuşak köşeli beyaz arka plan
        tft.drawWideLine(260, 70, 60, 70, 4, TFT_RED, TFT_RED);  // uzun kırmızı çizgi

        tft.setTextColor(TFT_GREY, TFT_WHITE);
        tft.setFreeFont(FSS24);

        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 175, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[106], 100, 28);  // adjust 0 VDC
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 72, 190);  // Range
        } else if (language == Turkish) {
          tft.drawString(turkish[106], 101, 28);  // ayarla 0 VDC
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 80, 190);  // Aralik
        }
        tft.drawString("= 0 - 255", 150, 190);
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;
        screen_switch = output_calibration_analog_out_3_VDC;
      } else if (button_state == press_enter) {
        button_state = idle;

        if (calibration_value >= 0 && calibration_value <= 255) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          lower_limit_VDC = calibration_value;

          EEPROM.writeUShort(lower_limit_VDC_address, lower_limit_VDC);

          EEPROM.commit();  // kaydet

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          tft.setFreeFont(FSSB9);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 72, 190);  // Range
            tft.drawString("= 0 - 255", 150, 190);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 80, 190);  // Aralik
            tft.drawString("= 0 - 255", 150, 190);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap

          tft.setTextColor(TFT_RED, TFT_WHITE);
          tft.setFreeFont(FSSB9);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 72, 190);  // Range
            tft.drawString("= 0 - 255", 150, 190);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 95, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 80, 190);  // Aralik
            tft.drawString("= 0 - 255", 150, 190);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }

      } else if (button_state == press_up) {
        button_state = idle;

        calibration_value++;
        if (calibration_value == 65535) calibration_value = 0;
        else if (calibration_value > 255) calibration_value = 255;

        // dacWrite(DAC_2_PIN_V, calibration_value);

        tft.setFreeFont(FSS24);
        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 175, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama

      } else if (button_state == press_down) {
        button_state = idle;

        calibration_value--;
        if (calibration_value == 65535) calibration_value = 0;
        else if (calibration_value > 255) calibration_value = 255;

        // dacWrite(DAC_2_PIN_V, calibration_value);

        tft.setFreeFont(FSS24);
        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 175, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama
      }

      break;

    case set_upper_analog_out_3_VDC:

      if (opening_page == true) {
        opening_page = false;

        calibration_value = upper_limit_VDC;

        // dacWrite(DAC_2_PIN_V, calibration_value);

        tft.fillScreen(0xc658);
        tft.fillRoundRect(20, 4, 280, 232, 15, TFT_WHITE);       // yumuşak köşeli beyaz arka plan
        tft.drawWideLine(260, 70, 60, 70, 4, TFT_RED, TFT_RED);  // uzun kırmızı çizgi

        tft.setTextColor(TFT_GREY, TFT_WHITE);
        tft.setFreeFont(FSS24);

        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 195, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[107], 95, 28);  // adjust 10 VDC
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 72, 190);  // Range
        } else if (language == Turkish) {
          tft.drawString(turkish[107], 95, 28);  // ayarla 10 V
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 80, 190);  // Aralik
        }
        tft.drawString("= 0 - 255", 150, 190);
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;
        screen_switch = output_calibration_analog_out_3_VDC;
      } else if (button_state == press_enter) {
        button_state = idle;

        if (calibration_value >= 0 && calibration_value <= 255) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          upper_limit_VDC = calibration_value;

          EEPROM.writeUShort(upper_limit_VDC_address, upper_limit_VDC);

          EEPROM.commit();  // kaydet

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          tft.setFreeFont(FSSB9);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 72, 190);  // Range
            tft.drawString("= 0 - 255", 150, 190);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 80, 190);  // Aralik
            tft.drawString("= 0 - 255", 150, 190);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap

          tft.setTextColor(TFT_RED, TFT_WHITE);
          tft.setFreeFont(FSSB9);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 72, 190);  // Range
            tft.drawString("= 0 - 255", 150, 190);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 95, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 80, 190);  // Aralik
            tft.drawString("= 0 - 255", 150, 190);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }

      } else if (button_state == press_up) {
        button_state = idle;

        calibration_value++;
        if (calibration_value == 65535) calibration_value = 0;
        else if (calibration_value > 255) calibration_value = 255;

        // dacWrite(DAC_2_PIN_V, calibration_value);

        tft.setFreeFont(FSS24);
        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 195, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama

      } else if (button_state == press_down) {
        button_state = idle;

        calibration_value--;
        if (calibration_value == 65535) calibration_value = 0;
        else if (calibration_value > 255) calibration_value = 255;

        // dacWrite(DAC_2_PIN_V, calibration_value);

        tft.setFreeFont(FSS24);
        sprintf(calibration_value_buffer, "%5d", calibration_value);
        tft.setTextDatum(TR_DATUM);                                 // Sağa yaslı hizalama
        tft.drawString(calibration_value_buffer, 195, 110, FONT6);  // Sayıyı ekrana yazdır
        tft.setTextDatum(TL_DATUM);                                 // Sola yaslı hizalama
      }

      break;

    case digital_output:

      if (opening_page == true) {
        opening_page = false;
        cursor = digital_out_1;
        tft.fillScreen(0xc658);
        digital_out_2_bar(high_light);
        digital_out_3_bar(high_light);
        centered_digital_output_bar(high_light);
        digital_out_1_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = output;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > digital_out_3) cursor = digital_out_1;  // kursoru baştaysa sona döndür
      if (cursor < digital_out_1) cursor = digital_out_3;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == digital_out_1) {
          if (previous_cursor == digital_out_2) {
            digital_out_2_bar(high_light);
          } else if (previous_cursor == digital_out_3) {
            digital_out_3_bar(high_light);
          }
          digital_out_1_bar(low_light);
        } else if (cursor == digital_out_2) {
          if (previous_cursor == digital_out_1) {
            digital_out_1_bar(high_light);
          } else if (previous_cursor == digital_out_3) {
            digital_out_3_bar(high_light);
          }
          digital_out_2_bar(low_light);
        } else if (cursor == digital_out_3) {
          if (previous_cursor == digital_out_1) {
            digital_out_1_bar(high_light);
          } else if (previous_cursor == digital_out_2) {
            digital_out_2_bar(high_light);
          }
          digital_out_3_bar(low_light);
        }
        previous_cursor = cursor;
      }
      break;

    case digital_out_1:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = digital_output;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(output_icon, 55, 75, left_aligned, 148, 149, 84, 150, 218, pulse_factor, min_frequency);

      break;

    case digital_out_2:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = digital_output;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick(65);  // yazı başlangıcından 35 eksik olmalı

        if (cursor == high_flow_alarm) {
          D_out_2_alarm_state = 4;
          tick_location = 1;
        } else if (cursor == low_flow_alarm) {
          D_out_2_alarm_state = 8;
          tick_location = 2;
        } else if (cursor == conductivity) {
          D_out_2_alarm_state = 1;
          tick_location = 3;
        } else if (cursor == system_alarm) {
          D_out_2_alarm_state = 2;
          tick_location = 4;
        } else if (cursor == direction) {
          D_out_2_alarm_state = 16;
          tick_location = 5;
        }

        EEPROM.writeUShort(D_out_2_alarm_state_address, D_out_2_alarm_state);

        EEPROM.commit();  // kaydet

        write_tick(65);  // yazı başlangıcından 35 eksik olmalı

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        tick_location = 0;

        if (D_out_2_alarm_state == 4) tick_location = 1;
        else if (D_out_2_alarm_state == 8) tick_location = 2;
        else if (D_out_2_alarm_state == 1) tick_location = 3;
        else if (D_out_2_alarm_state == 2) tick_location = 4;
        else if (D_out_2_alarm_state == 16) tick_location = 5;
      }

      bar_select(output_icon, 56, 100, middle_aligned, 62, 63, 64, 65, 66, high_flow_alarm, direction);


      break;

    case digital_out_3:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = digital_output;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick(65);  // yazı başlangıcından 35 eksik olmalı

        if (cursor == high_flow_alarm) {
          D_out_3_alarm_state = 4;
          tick_location = 1;
        } else if (cursor == low_flow_alarm) {
          D_out_3_alarm_state = 8;
          tick_location = 2;
        } else if (cursor == conductivity) {
          D_out_3_alarm_state = 1;
          tick_location = 3;
        } else if (cursor == system_alarm) {
          D_out_3_alarm_state = 2;
          tick_location = 4;
        } else if (cursor == direction) {
          D_out_3_alarm_state = 16;
          tick_location = 5;
        }

        EEPROM.writeUShort(D_out_3_alarm_state_address, D_out_3_alarm_state);

        EEPROM.commit();  // kaydet

        write_tick(65);  // yazı başlangıcından 35 eksik olmalı

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        previous_tick_location = 50;
        tick_location = 0;

        if (D_out_3_alarm_state == 4) tick_location = 1;
        else if (D_out_3_alarm_state == 8) tick_location = 2;
        else if (D_out_3_alarm_state == 1) tick_location = 3;
        else if (D_out_3_alarm_state == 2) tick_location = 4;
        else if (D_out_3_alarm_state == 16) tick_location = 5;
      }

      bar_select(output_icon, 57, 100, middle_aligned, 62, 63, 64, 65, 66, high_flow_alarm, direction);

      break;

    case high_alarm_out_fnc:

      static uint16_t high_alarm_out_fnc_register;

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = out_functions;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        if (cursor == pulse_frequency) {
          opening_page = true;
          screen_switch = pulse_frequency;  // ayarlar sayfasına git
          break;
        }

        delete_tick(65);  // yazı başlangıcından 35 eksik olmalı

        if (cursor == high_flow_alarm) {
          high_alarm_out_fnc_register = 2;
          tick_location = 2;
        } else if (cursor == low_flow_alarm) {
          high_alarm_out_fnc_register = 3;
          tick_location = 3;
        } else if (cursor == conductivity) {
          high_alarm_out_fnc_register = 5;
          tick_location = 4;
        } else if (cursor == system_alarm) {
          high_alarm_out_fnc_register = 6;
          tick_location = 5;
        } else if (cursor == direction) {
          high_alarm_out_fnc_register = 4;
          tick_location = 6;
        }

        modbus_master.read_or_write(1, WRITE_MULTI, 0x0112, &high_alarm_out_fnc_register);
        delay(time_after_communication);

        write_tick(65);  // yazı başlangıcından 35 eksik olmalı

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        tick_location = 0;
        modbus_master.read_or_write(1, READ_HOLDING, 0x0112, &high_alarm_out_fnc_register);
        delay(time_after_communication);

        if (high_alarm_out_fnc_register == 2) tick_location = 2;
        else if (high_alarm_out_fnc_register == 3) tick_location = 3;
        else if (high_alarm_out_fnc_register == 4) tick_location = 6;
        else if (high_alarm_out_fnc_register == 5) tick_location = 4;
        else if (high_alarm_out_fnc_register == 6) tick_location = 5;
      }

      bar_select(output_icon, 146, 100, middle_aligned, 61, 62, 63, 64, 65, 66, pulse_frequency, direction);

      break;

    case low_alarm_out_fnc:

      static uint16_t low_alarm_out_fnc_register;

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = out_functions;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick(65);  // yazı başlangıcından 35 eksik olmalı

        if (cursor == high_flow_alarm) {
          low_alarm_out_fnc_register = 2;
          tick_location = 1;
        } else if (cursor == low_flow_alarm) {
          low_alarm_out_fnc_register = 0;
          tick_location = 2;
        } else if (cursor == conductivity) {
          low_alarm_out_fnc_register = 3;
          tick_location = 3;
        } else if (cursor == system_alarm) {
          low_alarm_out_fnc_register = 4;
          tick_location = 4;
        } else if (cursor == direction) {
          low_alarm_out_fnc_register = 1;
          tick_location = 5;
        }

        modbus_master.read_or_write(1, WRITE_MULTI, 0x0143, &low_alarm_out_fnc_register);
        delay(time_after_communication);

        write_tick(65);  // yazı başlangıcından 35 eksik olmalı

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        modbus_master.read_or_write(1, READ_HOLDING, 0x0143, &low_alarm_out_fnc_register);
        delay(time_after_communication);

        if (low_alarm_out_fnc_register == 0) tick_location = 2;
        else if (low_alarm_out_fnc_register == 1) tick_location = 5;
        else if (low_alarm_out_fnc_register == 2) tick_location = 1;
        else if (low_alarm_out_fnc_register == 3) tick_location = 3;
        else if (low_alarm_out_fnc_register == 4) tick_location = 4;
      }

      bar_select(output_icon, 147, 100, middle_aligned, 62, 63, 64, 65, 66, high_flow_alarm, direction);

      break;

    case pulse_frequency:

      if (opening_page == true) {
        opening_page = false;
        cursor = pulse;
        tft.fillScreen(0xc658);
        frequency_bar(high_light);
        centered_pulse_frequency_bar(high_light);
        pulse_bar(low_light);

        modbus_master.read_or_write(1, READ_HOLDING, 0x0112, &digital_out_selection);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        write_tick_for_pulse_freqency();
      }

      if (cursor > frequency) cursor = pulse;  // kursoru baştaysa sona döndür
      if (cursor < pulse) cursor = frequency;  // kursoru sondaysa başa döndür
      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = high_alarm_out_fnc;  // ayarlar sayfasına git
        break;
      }
      if (button_state == press_enter) {
        button_state = idle;

        delete_tick_for_pulse_freqency();

        if (cursor == pulse) digital_out_selection = 1;
        else if (cursor == frequency) digital_out_selection = 0;

        modbus_master.read_or_write(1, WRITE_MULTI, 0x0112, &digital_out_selection);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        write_tick_for_pulse_freqency();
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == pulse) {
          frequency_bar(high_light);
          pulse_bar(low_light);
        } else if (cursor == frequency) {
          pulse_bar(high_light);
          frequency_bar(low_light);
        }
        previous_cursor = cursor;
        write_tick_for_pulse_freqency();
      }

      break;

    case pulse_factor:
    case _pulse_factor:

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;
        fixed_digit = 3;

        modbus_master.read_or_write(1, READ_HOLDING, 0x10, &pulse_unit);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        modbus_master.read_or_write(1, READ_HOLDING, 0x11, &uint16_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        read_or_write_number = (float)uint16_value / 1000.0f;

        number_entry_opening_page(read_or_write_number, positive, non_decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz

        digit = 2;

        tft.setFreeFont(FSS12);
        if (pulse_unit == 1) {
          tft.drawString("/ m3", 241, 117);
        } else if (pulse_unit == 0) {
          tft.drawString("/ L", 241, 117);
        }

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[148], 90, 28);  // Pulse factor
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 50, 185);  // Range
        } else if (language == Turkish) {
          tft.drawString(turkish[148], 45, 28);  // Pulse faktoru
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 50, 185);  // Aralik
        }
        tft.drawString("=  0 - 59.999", 130, 185);
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;
        fixed_digit = 50;

        opening_page = true;

        if (previous_screen_switch == quick_setup) {
          screen_switch = quick_setup;
          previous_screen_switch = 0;
        } else {
          screen_switch = digital_out_1;
        }

        break;

      } else if (button_state == press_enter) {
        button_state = idle;

        number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

        if (read_or_write_number >= 0 && read_or_write_number < 60.0) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          uint16_value = (uint16_t)(read_or_write_number * 1000.0f);

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x11, &uint16_value);
          delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 50, 185);  // Range
            tft.drawString("=  0 - 59.999", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 50, 185);  // Aralik
            tft.drawString("=  0 - 59.999", 130, 185);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını 1 sn kırmızı yap
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_RED, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 50, 185);  // Range
            tft.drawString("=  0 - 59.999", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 95, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 50, 185);  // Aralik
            tft.drawString("=  0 - 59.999", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }


      } else if (button_state == press_up) {
        button_state = idle;

        increase_digit_number();
      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
        if (digit == 4) digit = 5;
        if (digit == 8) digit = 2;  // cursorun başa dönmesi için
      }
      cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir

      break;

    case pulse_width:

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;
        fixed_digit = 5;

        modbus_master.read_or_write(1, READ_HOLDING, 0x12, &uint16_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        read_or_write_number = (float)uint16_value / 10.0f;

        number_entry_opening_page(read_or_write_number, positive, non_decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz

        digit = 2;

        tft.setFreeFont(FSS12);
        tft.drawString("ms", 245, 118);

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[149], 90, 30);  // Pulse Width
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 50, 185);  // Range
        } else if (language == Turkish) {
          tft.drawString(turkish[149], 46, 20);  // Pulse genişliği
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 50, 185);  // Aralik
        }
        tft.drawString("= 0.5 - 1999.9", 130, 185);
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;
        fixed_digit = 50;

        opening_page = true;

        screen_switch = digital_out_1;

        break;

      } else if (button_state == press_enter) {
        button_state = idle;

        number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

        if (read_or_write_number >= 0.5f && read_or_write_number < 2000) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          uint16_value = (uint16_t)(read_or_write_number * 10.0f);

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x12, &uint16_value);
          delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 50, 185);  // Range
            tft.drawString("= 0.5 - 1999.9", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 50, 185);  // Aralik
            tft.drawString("= 0.5 - 1999.9", 130, 185);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını 1 sn kırmızı yap
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_RED, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 50, 185);  // Range
            tft.drawString("= 0.5 - 1999.9", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 95, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 50, 185);  // Aralik
            tft.drawString("= 0.5 - 1999.9", 130, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }


      } else if (button_state == press_up) {
        button_state = idle;

        increase_digit_number();
      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
        if (digit == 6) digit = 7;
        if (digit == 8) digit = 2;  // cursorun başa dönmesi için
      }

      cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir

      break;

    case max_frequency:

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;

        modbus_master.read_or_write(1, READ_HOLDING, 0x13, &uint16_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        read_or_write_number = (float)uint16_value;
        number_entry_opening_page(read_or_write_number, positive, decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz

        digit = 3;

        tft.setFreeFont(FSS12);
        tft.drawString("Hz", 245, 118);

        if (language == English) {
          tft.setFreeFont(FSS18);
          tft.drawString(english[150], 40, 20);  // Max Frequency
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 55, 185);  // Range
        } else if (language == Turkish) {
          tft.setFreeFont(FSS18);
          tft.drawString(turkish[150], 60, 20);  // Max frekans
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 67, 185);
        }
        tft.drawString("= 0 - 10000", 135, 185);
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;

        screen_switch = digital_out_1;

        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

        if (read_or_write_number >= 0 && read_or_write_number <= 10000) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          uint16_value = (uint16_t)read_or_write_number;

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x13, &uint16_value);
          delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 55, 185);  // Range
            tft.drawString("= 0 - 10000", 135, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 67, 185);  // Aralik
            tft.drawString("= 0 - 10000", 135, 185);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını 1 sn kırmızı yap
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_RED, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 55, 185);  // Range
            tft.drawString("= 0 - 10000", 135, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 95, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 67, 185);  // Aralik
            tft.drawString("= 0 - 10000", 135, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }

      } else if (button_state == press_up) {
        button_state = idle;

        increase_digit_number();
      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
        if (digit == 8) digit = 3;  // cursorun başa dönmesi için
      }
      cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir

      break;

    case min_frequency:

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;

        modbus_master.read_or_write(1, READ_HOLDING, 0x37, &uint16_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        read_or_write_number = (float)uint16_value;

        number_entry_opening_page(read_or_write_number, positive, decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz

        digit = 4;

        tft.setFreeFont(FSS12);
        tft.drawString("Hz", 245, 118);

        if (language == English) {
          tft.setFreeFont(FSS18);
          tft.drawString(english[218], 40, 20);  // Min Frequency
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 55, 185);  // Range
        } else if (language == Turkish) {
          tft.setFreeFont(FSS18);
          tft.drawString(turkish[218], 60, 20);  // Min frekans
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 67, 185);
        }
        tft.drawString("= 0 - 9999", 135, 185);
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;

        screen_switch = digital_out_1;

        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

        if (read_or_write_number >= 0 && read_or_write_number <= 9999) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          uint16_value = (uint16_t)read_or_write_number;

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x37, &uint16_value);
          delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 55, 185);  // Range
            tft.drawString("= 0 - 9999", 135, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 67, 185);  // Aralik
            tft.drawString("= 0 - 9999", 135, 185);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını 1 sn kırmızı yap
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_RED, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 55, 185);  // Range
            tft.drawString("= 0 - 9999", 135, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 95, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 67, 185);  // Aralik
            tft.drawString("= 0 - 9999", 135, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }

      } else if (button_state == press_up) {
        button_state = idle;

        increase_digit_number();
      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
        if (digit == 8) digit = 4;  // cursorun başa dönmesi için
      }
      cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir

      break;

    case output_type:

      uint16_t pulse_or_frequency;

      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;

        screen_switch = digital_out_1;  // ayarlar sayfasına git

        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (cursor == frequency) {
          pulse_or_frequency = 0;
          tick_location = 1;
        } else if (cursor == pulse) {
          pulse_or_frequency = 1;
          tick_location = 2;
        }

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x0F, &pulse_or_frequency);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        tick_location = 0;
        previous_tick_location = tick_location;
        cursor = forward;

        modbus_master.read_or_write(1, READ_HOLDING, 0x0F, &pulse_or_frequency);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        if (pulse_or_frequency == 0) tick_location = 1;
        else if (pulse_or_frequency == 1) tick_location = 2;
      }

      bar_select(output_icon, 84, 140, middle_aligned, 68, 67, frequency, pulse);

      break;

    case alarms:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = output;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(output_icon, 130, 75, left_aligned, 229, 136, 137, 138, alarm_output, sys_alarm);

      break;

    case alarm_output:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;

        screen_switch = alarms;

        break;

      } else if (button_state == press_enter) {
        button_state = idle;

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x40, &protect_password);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (cursor == high_flow) uint16_value = 1;
        else if (cursor == low_flow) uint16_value = 2;
        else if (cursor == empty_pipe) uint16_value = 3;
        else if (cursor == reverse_direction) uint16_value = 4;
        else if (cursor == system_) uint16_value = 6;
        else if (cursor == disable_alarm) uint16_value = 0;

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x45, &uint16_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (uint16_value == 1) tick_location = 1;
        else if (uint16_value == 2) tick_location = 2;
        else if (uint16_value == 3) tick_location = 3;
        else if (uint16_value == 4) tick_location = 4;
        else if (uint16_value == 6) tick_location = 5;
        else if (uint16_value == 0) tick_location = 6;

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        previous_cursor = 100;
        first_text = true;
        modbus_master.read_or_write(1, READ_HOLDING, 0x45, &uint16_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre
        cursor = high_flow;
      }

      if (opening_page == true) {

        previous_tick_location = 100;
        if (uint16_value == 1) tick_location = 1;
        else if (uint16_value == 2) tick_location = 2;
        else if (uint16_value == 3) tick_location = 3;
        else if (uint16_value == 4) tick_location = 4;
        else if (uint16_value == 6) tick_location = 5;
        else if (uint16_value == 0) tick_location = 6;
      }

      bar_select(output_icon, 229, 120, middle_aligned, 230, 231, 232, 233, 234, 235, high_flow, disable_alarm);

      break;

    case high_alarm:

      static uint16_t high_alarm_enable;

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;

        modbus_master.read_or_write(1, READ_HOLDING, 0x15, &uint16_value);  // Registerdan istenilen değeri oku
        delay(time_after_communication);                                    // iki modbus haberleşmesi arası beklenecek min süre

        // Akış birimi oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x07, &flow_unit_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (flow_unit_value == 5) {  // m3
          fixed_digit = 5;
          read_or_write_number = (float)uint16_value / 10.0f;                             // Okunan değeri basamaklara ayrılıp ekrana yazılması için global değişkene at
          number_entry_opening_page(read_or_write_number, positive, non_decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz
          tft.setFreeFont(FSS12);
          tft.drawString("/ m3", 241, 117);
          tft.drawString("=  0 - 3276.7", 130, 190);
          digit = 2;
        } else if (flow_unit_value == 2) {  // L
          fixed_digit = 50;
          number_entry_opening_page(uint16_value, positive, decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz
          tft.setFreeFont(FSS12);
          tft.drawString("/ L", 241, 117);
          tft.drawString("=  0 - 32767", 130, 190);
          digit = 3;
        }

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[230], 97, 14);  // high flow
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 50, 190);  // Range
        } else if (language == Turkish) {
          tft.drawString(turkish[111], 100, 14);
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[230], 90, 190);
        }

        modbus_master.read_or_write(1, READ_HOLDING, 0x14, &high_alarm_enable);  // Registerdan istenilen değeri oku
        delay(time_after_communication);                                         // iki modbus haberleşmesi arası beklenecek min süre

        tft.setTextColor(TFT_GREY, TFT_WHITE);
        tft.setFreeFont(FSS9);
        tft.drawString(english[76], 46, 40);   // active
        tft.drawString(english[77], 213, 40);  // passive

        tft.drawWideLine(275, 70, 45, 70, 4, TFT_RED, TFT_RED);  // uzun kırmızı çizgi

        tft.drawRect(57, 14, 20, 20, TFT_DARKGREEN);  // soldaki içi boş kare
        tft.drawRect(231, 14, 20, 20, TFT_RED);       // sağdaki içi boş kare

        if (high_alarm_enable == 0) {  // sensitivity_ kapalı
          tft.fillRect(232, 15, 18, 18, TFT_RED);
        } else if (high_alarm_enable == 1) {  // sensitivity_ açık
          tft.fillRect(58, 15, 18, 18, TFT_DARKGREEN);
        }
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = alarms;
        fixed_digit = 50;
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        if (high_alarm_enable == 1) {

          if (digit == 8) {
            high_alarm_enable = 0;
            tft.fillRect(58, 15, 18, 18, TFT_WHITE);
            tft.fillRect(232, 15, 18, 18, TFT_RED);

            modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
            delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

            modbus_master.read_or_write(1, WRITE_SINGLE, 0x14, &high_alarm_enable);  // Registerdan istenilen değeri oku
            delay(time_after_communication);                                         // iki modbus haberleşmesi arası beklenecek min süre
          } else {

            number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

            if (flow_unit_value == 5) {                                            // m3
              if (read_or_write_number >= 0 && read_or_write_number <= 3276.7f) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
                delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

                uint16_value = (uint16_t)(read_or_write_number * 10.0f);

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x15, &uint16_value);  // Registerdan istenilen değeri oku
                delay(time_after_communication);                                    // iki modbus haberleşmesi arası beklenecek min süre


                tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
                tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[2], 135, 162);  // done !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 3276.7", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[2], 112, 162);  // onaylandi !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 50, 190);  // Aralik
                  tft.drawString("=  0 - 3276.7", 130, 190);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap
                tft.setTextColor(TFT_RED, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[73], 105, 162);  // out of range
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 3276.7", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[73], 95, 162);  // araligin disinda
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 50, 190);  // Aralik
                  tft.drawString("=  0 - 3276.7", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              }
            } else if (flow_unit_value == 2) {                                   // L
              if (read_or_write_number >= 0 && read_or_write_number <= 32767) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
                delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

                uint16_value = (uint16_t)read_or_write_number;

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x15, &uint16_value);  // Registerdan istenilen değeri oku
                delay(time_after_communication);                                    // iki modbus haberleşmesi arası beklenecek min süre


                tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
                tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[2], 135, 162);  // done !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 32767", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[2], 112, 162);  // onaylandi !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 50, 190);  // Aralik
                  tft.drawString("=  0 - 32767", 130, 190);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap
                tft.setTextColor(TFT_RED, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[73], 105, 162);  // out of range
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 32767", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[73], 95, 162);  // araligin disinda
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 50, 190);  // Aralik
                  tft.drawString("=  0 - 32767", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              }
            }
          }
        } else {
          high_alarm_enable = 1;
          tft.fillRect(232, 15, 18, 18, TFT_WHITE);
          tft.fillRect(58, 15, 18, 18, TFT_DARKGREEN);

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x14, &high_alarm_enable);  // Registerdan istenilen değeri oku
          delay(time_after_communication);                                         // iki modbus haberleşmesi arası beklenecek min süre

          if (flow_unit_value == 5) {  // m3 için
            digit = 2;
          } else digit = 3;  // L için
        }

      } else if (button_state == press_up) {
        button_state = idle;

        if (high_alarm_enable == 1) {
          increase_digit_number();
        }
      } else if (button_state == press_down) {
        button_state = idle;
        if (high_alarm_enable == 1) {
          digit++;

          if (digit > 8) {

            if (flow_unit_value == 5) {  // m3 için
              digit = 2;
            } else digit = 3;  // L için
            tft.fillRect(232, 15, 18, 18, TFT_WHITE);
          }

          if (digit == 8) {
            tft.drawWideLine(57 + digit - 1 * 25, 147, 34 + digit * 25, 147, 4, TFT_WHITE, TFT_WHITE);  // imleç kutucuklara geçince önceki pozisyonunun kalıntısını sil
            half_second = previous_half_second;
          }

          if (flow_unit_value == 5) {  // m3 için
            if (digit == 6) digit = 7;
          }
        }
      }

      if (high_alarm_enable == 0) {  // kutu animasyonları

        if (half_second != previous_half_second) {
          if (green_rectengular == true) {  // red line çizilimi
            tft.fillRect(58, 15, 18, 18, TFT_WHITE);
          } else {
            tft.fillRect(58, 15, 18, 18, TFT_DARKGREEN);
          }
          green_rectengular = !green_rectengular;
          previous_half_second = half_second;
        }
      } else {
        if (digit == 8) {
          if (half_second != previous_half_second) {
            if (green_rectengular == true) {  // red line çizilimi
              tft.fillRect(232, 15, 18, 18, TFT_WHITE);
            } else {
              tft.fillRect(232, 15, 18, 18, TFT_RED);
            }
            green_rectengular = !green_rectengular;
            previous_half_second = half_second;
          }
        } else {
          cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir
        }
      }

      break;

    case low_alarm:

      static uint16_t low_alarm_enable;

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;

        modbus_master.read_or_write(1, READ_HOLDING, 0x17, &uint16_value);  // Registerdan istenilen değeri oku
        delay(time_after_communication);                                    // iki modbus haberleşmesi arası beklenecek min süre

        // Akış birimi oku
        modbus_master.read_or_write(1, READ_HOLDING, 0x07, &flow_unit_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (flow_unit_value == 5) {  // m3
          fixed_digit = 5;
          read_or_write_number = (float)uint16_value / 10.0f;                             // Okunan değeri basamaklara ayrılıp ekrana yazılması için global değişkene at
          number_entry_opening_page(read_or_write_number, positive, non_decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz
          tft.setFreeFont(FSS12);
          tft.drawString("/ m3", 241, 117);
          tft.drawString("=  0 - 3276.7", 130, 190);
          digit = 2;
        } else if (flow_unit_value == 2) {  // L
          fixed_digit = 50;
          number_entry_opening_page(uint16_value, positive, decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz
          tft.setFreeFont(FSS12);
          tft.drawString("/ L", 241, 117);
          tft.drawString("=  0 - 32767", 130, 190);
          digit = 3;
        }

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[231], 94, 14);  // low flow
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 50, 190);  // Range
        } else if (language == Turkish) {
          tft.drawString(turkish[231], 100, 14);
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[230], 90, 190);
        }

        modbus_master.read_or_write(1, READ_HOLDING, 0x16, &low_alarm_enable);  // Registerdan istenilen değeri oku
        delay(time_after_communication);                                        // iki modbus haberleşmesi arası beklenecek min süre

        tft.setTextColor(TFT_GREY, TFT_WHITE);
        tft.setFreeFont(FSS9);
        tft.drawString(english[76], 46, 40);   // active
        tft.drawString(english[77], 213, 40);  // passive

        tft.drawWideLine(275, 70, 45, 70, 4, TFT_RED, TFT_RED);  // uzun kırmızı çizgi

        tft.drawRect(57, 14, 20, 20, TFT_DARKGREEN);  // soldaki içi boş kare
        tft.drawRect(231, 14, 20, 20, TFT_RED);       // sağdaki içi boş kare

        if (low_alarm_enable == 0) {  // sensitivity_ kapalı
          tft.fillRect(232, 15, 18, 18, TFT_RED);
        } else if (low_alarm_enable == 1) {  // sensitivity_ açık
          tft.fillRect(58, 15, 18, 18, TFT_DARKGREEN);
        }
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = alarms;
        fixed_digit = 50;
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        if (low_alarm_enable == 1) {

          if (digit == 8) {
            low_alarm_enable = 0;
            tft.fillRect(58, 15, 18, 18, TFT_WHITE);
            tft.fillRect(232, 15, 18, 18, TFT_RED);

            modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
            delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

            modbus_master.read_or_write(1, WRITE_SINGLE, 0x16, &low_alarm_enable);  // Registerdan istenilen değeri oku
            delay(time_after_communication);                                        // iki modbus haberleşmesi arası beklenecek min süre
          } else {

            number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

            if (flow_unit_value == 5) {                                            // m3
              if (read_or_write_number >= 0 && read_or_write_number <= 3276.7f) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
                delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

                uint16_value = (uint16_t)(read_or_write_number * 10.0f);

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x17, &uint16_value);  // Registerdan istenilen değeri oku
                delay(time_after_communication);                                    // iki modbus haberleşmesi arası beklenecek min süre


                tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
                tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[2], 135, 162);  // done !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 3276.7", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[2], 112, 162);  // onaylandi !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 50, 190);  // Aralik
                  tft.drawString("=  0 - 3276.7", 130, 190);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap
                tft.setTextColor(TFT_RED, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[73], 105, 162);  // out of range
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 3276.7", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[73], 95, 162);  // araligin disinda
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 50, 190);  // Aralik
                  tft.drawString("=  0 - 3276.7", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              }
            } else if (flow_unit_value == 2) {                                   // L
              if (read_or_write_number >= 0 && read_or_write_number <= 32767) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
                delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

                uint16_value = (uint16_t)read_or_write_number;

                modbus_master.read_or_write(1, WRITE_SINGLE, 0x17, &uint16_value);  // Registerdan istenilen değeri oku
                delay(time_after_communication);                                    // iki modbus haberleşmesi arası beklenecek min süre


                tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
                tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[2], 135, 162);  // done !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 32767", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[2], 112, 162);  // onaylandi !
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 50, 190);  // Aralik
                  tft.drawString("=  0 - 32767", 130, 190);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap
                tft.setTextColor(TFT_RED, TFT_WHITE);
                tft.setFreeFont(FSSB9);
                if (language == English) {
                  tft.drawString(english[73], 105, 162);  // out of range
                  tft.setFreeFont(FSS12);
                  tft.drawString(english[69], 50, 190);  // Range
                  tft.drawString("=  0 - 32767", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                } else if (language == Turkish) {
                  tft.drawString(turkish[73], 95, 162);  // araligin disinda
                  tft.setFreeFont(FSS12);
                  tft.drawString(turkish[69], 50, 190);  // Aralik
                  tft.drawString("=  0 - 32767", 130, 190);
                  tft.setTextColor(TFT_GREY, TFT_WHITE);
                }
                delay(1000);
                tft.drawString("                            ", 75, 162);
              }
            }
          }
        } else {
          low_alarm_enable = 1;
          tft.fillRect(232, 15, 18, 18, TFT_WHITE);
          tft.fillRect(58, 15, 18, 18, TFT_DARKGREEN);

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x0040, &protect_password);
          delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

          modbus_master.read_or_write(1, WRITE_SINGLE, 0x16, &low_alarm_enable);  // Registerdan istenilen değeri oku
          delay(time_after_communication);                                        // iki modbus haberleşmesi arası beklenecek min süre

          if (flow_unit_value == 5) {  // m3 için
            digit = 2;
          } else digit = 3;  // L için
        }

      } else if (button_state == press_up) {
        button_state = idle;

        if (low_alarm_enable == 1) {
          increase_digit_number();
        }
      } else if (button_state == press_down) {
        button_state = idle;
        if (low_alarm_enable == 1) {
          digit++;

          if (digit > 8) {

            if (flow_unit_value == 5) {  // m3 için
              digit = 2;
            } else digit = 3;  // L için
            tft.fillRect(232, 15, 18, 18, TFT_WHITE);
          }

          if (digit == 8) {
            tft.drawWideLine(57 + digit - 1 * 25, 147, 34 + digit * 25, 147, 4, TFT_WHITE, TFT_WHITE);  // imleç kutucuklara geçince önceki pozisyonunun kalıntısını sil
            half_second = previous_half_second;
          }

          if (flow_unit_value == 5) {  // m3 için
            if (digit == 6) digit = 7;
          }
        }
      }

      if (low_alarm_enable == 0) {  // kutu animasyonları

        if (half_second != previous_half_second) {
          if (green_rectengular == true) {  // red line çizilimi
            tft.fillRect(58, 15, 18, 18, TFT_WHITE);
          } else {
            tft.fillRect(58, 15, 18, 18, TFT_DARKGREEN);
          }
          green_rectengular = !green_rectengular;
          previous_half_second = half_second;
        }
      } else {
        if (digit == 8) {
          if (half_second != previous_half_second) {
            if (green_rectengular == true) {  // red line çizilimi
              tft.fillRect(232, 15, 18, 18, TFT_WHITE);
            } else {
              tft.fillRect(232, 15, 18, 18, TFT_RED);
            }
            green_rectengular = !green_rectengular;
            previous_half_second = half_second;
          }
        } else {
          cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir
        }
      }

      break;

    case sys_alarm:

      static uint16_t sys_alarm_value;

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = alarms;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        if (cursor == enable) {
          sys_alarm_value = 1;
          tick_location = 1;
        } else if (cursor == disable) {
          sys_alarm_value = 0;
          tick_location = 2;
        }

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x40, &protect_password);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x22, &sys_alarm_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        tick_location = 0;
        previous_tick_location = tick_location;
        cursor = enable;

        modbus_master.read_or_write(1, READ_HOLDING, 0x22, &sys_alarm_value);
        delay(time_after_communication);  // iki modbus haberleşmesi arası beklenecek min süre

        if (sys_alarm_value == 1) tick_location = 1;
        else if (sys_alarm_value == 0) tick_location = 2;
      }

      bar_select(output_icon, 138, 140, middle_aligned, 128, 129, enable, disable);

      break;

    case communication:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = settings;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        if (cursor == modbus_ || cursor == wifi) {
          screen_switch = cursor;  // kursor nerdeyse o ayara git
          opening_page = true;
          if (cursor == wifi) first_text = true;
        }
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(communication_icon, 7, 75, left_aligned, 40, 41, 42, 43, 44, 45, modbus_, wifi);

      break;

    case modbus_:

      if (opening_page == true) {
        opening_page = false;
        cursor = modbus_baudrate;
        tft.fillScreen(0xc658);
        modbus_ID_bar(high_light);
        modbus_parity_bit_bar(high_light);
        modbus_stop_bit_bar(high_light);
        centered_modbus_bar(high_light);
        modbus_baudrate_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = communication;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > modbus_stop_bit) cursor = modbus_baudrate;  // kursoru baştaysa sona döndür
      if (cursor < modbus_baudrate) cursor = modbus_stop_bit;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == modbus_baudrate) {
          if (previous_cursor == modbus_stop_bit) {
            modbus_stop_bit_bar(high_light);
          } else if (previous_cursor == modbus_id) {
            modbus_ID_bar(high_light);
          }
          modbus_baudrate_bar(low_light);
        } else if (cursor == modbus_id) {
          if (previous_cursor == modbus_baudrate) {
            modbus_baudrate_bar(high_light);
          } else if (previous_cursor == modbus_parity_bit) {
            modbus_parity_bit_bar(high_light);
          }
          modbus_ID_bar(low_light);
        } else if (cursor == modbus_parity_bit) {
          if (previous_cursor == modbus_id) {
            modbus_ID_bar(high_light);
          } else if (previous_cursor == modbus_stop_bit) {
            modbus_stop_bit_bar(high_light);
          }
          modbus_parity_bit_bar(low_light);
        } else if (cursor == modbus_stop_bit) {
          if (previous_cursor == modbus_parity_bit) {
            modbus_parity_bit_bar(high_light);
          } else if (previous_cursor == modbus_baudrate) {
            modbus_baudrate_bar(high_light);
          }
          modbus_stop_bit_bar(low_light);
        }
        previous_cursor = cursor;
      }
      break;

    case modbus_baudrate:

      if (opening_page == true) {
        opening_page = false;
        cursor = baud_1200;
        tft.fillScreen(0xc658);
        baud_2400_bar(high_light);
        baud_4800_bar(high_light);
        baud_9600_bar(high_light);
        baud_19200_bar(high_light);
        baud_38400_bar(high_light);
        centered_modbus_baudrate_bar(high_light);
        baud_1200_bar(low_light);

        // Seçili baud rate e tik işaretini koy
        write_tick_for_baud_rate();
      }

      if (button_state == press_esc) {
        button_state = idle;
        screen_switch = modbus_;  // ayarlar sayfasına git
        opening_page = true;
      } else if (button_state == press_enter) {
        button_state = idle;

        // tik işaretini sil
        if (baud_rate_value == 1200) {
          draw_tick(105, 50, TFT_WHITE);
        } else if (baud_rate_value == 2400) {
          draw_tick(105, 83, TFT_WHITE);
        } else if (baud_rate_value == 4800) {
          draw_tick(105, 116, TFT_WHITE);
        } else if (baud_rate_value == 9600) {
          draw_tick(105, 149, TFT_WHITE);
        } else if (baud_rate_value == 19200) {
          draw_tick(105, 182, TFT_WHITE);
        } else if (baud_rate_value == 38400) {
          draw_tick(105, 215, TFT_WHITE);
        }

        // yeni baud rate değerini hazırla
        if (cursor == baud_1200) baud_rate_value = 1200;
        else if (cursor == baud_2400) baud_rate_value = 2400;
        else if (cursor == baud_4800) baud_rate_value = 4800;
        else if (cursor == baud_9600) baud_rate_value = 9600;
        else if (cursor == baud_19200) baud_rate_value = 19200;
        else if (cursor == baud_38400) baud_rate_value = 38400;

        if (stop_bit_value == 1) {
          if (parity_bit_value == 0) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N1, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 1) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O1, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 2) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E1, SLAVE_RX_PIN, SLAVE_TX_PIN);
          }
        } else if (stop_bit_value == 2) {
          if (parity_bit_value == 0) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N2, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 1) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O2, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 2) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E2, SLAVE_RX_PIN, SLAVE_TX_PIN);
          }
        }

        EEPROM.writeUShort(modbus_baud_rate_address, baud_rate_value);  // eeproma yazmaya hazırla

        EEPROM.commit();  // eeproma kaydet

        // tik işareti koy
        if (baud_rate_value == 1200) {
          draw_tick(105, 50, TFT_DARKGREEN);
        } else if (baud_rate_value == 2400) {
          draw_tick(105, 83, TFT_DARKGREEN);
        } else if (baud_rate_value == 4800) {
          draw_tick(105, 116, TFT_DARKGREEN);
        } else if (baud_rate_value == 9600) {
          draw_tick(105, 149, TFT_DARKGREEN);
        } else if (baud_rate_value == 19200) {
          draw_tick(105, 182, TFT_DARKGREEN);
        } else if (baud_rate_value == 38400) {
          draw_tick(105, 215, TFT_DARKGREEN);
        }

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > baud_38400) cursor = baud_1200;  // kursoru baştaysa sona döndür
      if (cursor < baud_1200) cursor = baud_38400;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == baud_1200) {
          if (previous_cursor == baud_38400) {
            baud_38400_bar(high_light);
          } else if (previous_cursor == baud_2400) {
            baud_2400_bar(high_light);
          }
          baud_1200_bar(low_light);
        } else if (cursor == baud_2400) {
          if (previous_cursor == baud_1200) {
            baud_1200_bar(high_light);
          } else if (previous_cursor == baud_4800) {
            baud_4800_bar(high_light);
          }
          baud_2400_bar(low_light);
        } else if (cursor == baud_4800) {
          if (previous_cursor == baud_2400) {
            baud_2400_bar(high_light);
          } else if (previous_cursor == baud_9600) {
            baud_9600_bar(high_light);
          }
          baud_4800_bar(low_light);
        } else if (cursor == baud_9600) {
          if (previous_cursor == baud_4800) {
            baud_4800_bar(high_light);
          } else if (previous_cursor == baud_19200) {
            baud_19200_bar(high_light);
          }
          baud_9600_bar(low_light);
        } else if (cursor == baud_19200) {
          if (previous_cursor == baud_9600) {
            baud_9600_bar(high_light);
          } else if (previous_cursor == baud_38400) {
            baud_38400_bar(high_light);
          }
          baud_19200_bar(low_light);
        } else if (cursor == baud_38400) {
          if (previous_cursor == baud_19200) {
            baud_19200_bar(high_light);
          } else if (previous_cursor == baud_1200) {
            baud_1200_bar(high_light);
          }
          baud_38400_bar(low_light);
        }
        previous_cursor = cursor;
        // Seçili baud rate e tik işaretini koy

        write_tick_for_baud_rate();
      }


      break;

    case modbus_id:

      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;

        read_or_write_number = slave_ID;                                            // Okunan değeri basamaklara ayrılıp ekrana yazılması için global değişkene at
        number_entry_opening_page(read_or_write_number, positive, decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz
        digit = 5;                                                                  // imleçin en sağdaki basamakta kalması için

        tft.setFreeFont(FSSB12);
        if (language == English) {
          tft.drawString(english[51], 95, 28);
          tft.setFreeFont(FSS12);
          tft.drawString(english[69], 75, 190);
        } else if (language == Turkish) {
          tft.drawString(turkish[51], 95, 28);
          tft.setFreeFont(FSS12);
          tft.drawString(turkish[69], 78, 190);
        }
        tft.drawString("= 1 - 247", 150, 190);
      }

      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;
        screen_switch = modbus_;
      } else if (button_state == press_enter) {
        button_state = idle;

        number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar
        uint16_value = (uint16_t)read_or_write_number;

        if (uint16_value >= 1 && uint16_value <= 247) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          slave_ID = (uint8_t)uint16_value;  // haberleşmenin devam etmesi için kendi ID adresini uyarla

                    if (stop_bit_value == 1) {
            if (parity_bit_value == 0) {
              modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N1, SLAVE_RX_PIN, SLAVE_TX_PIN);
            } else if (parity_bit_value == 1) {
              modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O1, SLAVE_RX_PIN, SLAVE_TX_PIN);
            } else if (parity_bit_value == 2) {
              modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E1, SLAVE_RX_PIN, SLAVE_TX_PIN);
            }
          } else if (stop_bit_value == 2) {
            if (parity_bit_value == 0) {
              modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N2, SLAVE_RX_PIN, SLAVE_TX_PIN);
            } else if (parity_bit_value == 1) {
              modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O2, SLAVE_RX_PIN, SLAVE_TX_PIN);
            } else if (parity_bit_value == 2) {
              modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E2, SLAVE_RX_PIN, SLAVE_TX_PIN);
            }
          }

          EEPROM.writeByte(slave_ID_eep_address, slave_ID);
          EEPROM.commit();  // kaydet

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          tft.setFreeFont(FSSB9);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 75, 190);  // Range
            tft.drawString("= 1 - 247", 150, 190);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 78, 190);  // Aralik
            tft.drawString("= 1 - 247", 150, 190);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını kırmızı yap
          tft.setTextColor(TFT_RED, TFT_WHITE);
          tft.setFreeFont(FSSB9);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 75, 190);  // Range
            tft.drawString("= 1 - 247", 150, 190);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 90, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 78, 190);  // Aralik
            tft.drawString("= 1 - 247", 150, 190);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }

      } else if (button_state == press_up) {
        button_state = idle;

        increase_digit_number();
      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
        if (digit > 7) digit = 5;
      }
      cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir
      break;

    case modbus_parity_bit:

      if (opening_page == true) {
        opening_page = false;
        cursor = none;
        tft.fillScreen(0xc658);
        odd_bar(high_light);
        even_bar(high_light);
        centered_modbus_parity_bit_bar(high_light);
        none_bar(low_light);

        // Seçili baud rate e tik işaretini koy
        write_tick_for_parity_bit();
      }

      if (button_state == press_esc) {
        button_state = idle;
        screen_switch = modbus_;  // ayarlar sayfasına git
        opening_page = true;
      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick_for_parity_bit();

        if (cursor == none) parity_bit_value = 0;
        else if (cursor == odd) parity_bit_value = 1;
        else if (cursor == even) parity_bit_value = 2;

        if (stop_bit_value == 1) {
          if (parity_bit_value == 0) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N1, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 1) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O1, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 2) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E1, SLAVE_RX_PIN, SLAVE_TX_PIN);
          }
        } else if (stop_bit_value == 2) {
          if (parity_bit_value == 0) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N2, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 1) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O2, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 2) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E2, SLAVE_RX_PIN, SLAVE_TX_PIN);
          }
        }

        EEPROM.writeUShort(modbus_parity_bit_address, parity_bit_value);  // eeproma yazmaya hazırla

        EEPROM.commit();  // eeproma kaydet

        write_tick_for_parity_bit();

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > even) cursor = none;  // kursoru baştaysa sona döndür
      if (cursor < none) cursor = even;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == none) {
          if (previous_cursor == even) {
            even_bar(high_light);
          } else if (previous_cursor == odd) {
            odd_bar(high_light);
          }
          none_bar(low_light);
        } else if (cursor == odd) {
          if (previous_cursor == none) {
            none_bar(high_light);
          } else if (previous_cursor == even) {
            even_bar(high_light);
          }
          odd_bar(low_light);
        } else if (cursor == even) {
          if (previous_cursor == none) {
            none_bar(high_light);
          } else if (previous_cursor == odd) {
            odd_bar(high_light);
          }
          even_bar(low_light);
        }
        previous_cursor = cursor;

        write_tick_for_parity_bit();
      }

      break;

    case modbus_stop_bit:

      if (opening_page == true) {
        opening_page = false;
        cursor = one;
        tft.fillScreen(0xc658);
        two_bar(high_light);
        centered_modbus_stop_bit_bar(high_light);
        one_bar(low_light);

        write_tick_for_stop_bit();
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = modbus_;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick_for_stop_bit();

        if (cursor == one) stop_bit_value = 1;
        else if (cursor == two) stop_bit_value = 2;

        if (stop_bit_value == 1) {
          if (parity_bit_value == 0) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N1, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 1) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O1, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 2) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E1, SLAVE_RX_PIN, SLAVE_TX_PIN);
          }
        } else if (stop_bit_value == 2) {
          if (parity_bit_value == 0) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8N2, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 1) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8O2, SLAVE_RX_PIN, SLAVE_TX_PIN);
          } else if (parity_bit_value == 2) {
            modbus_slave.begin(slave_ID, baud_rate_value, SERIAL_8E2, SLAVE_RX_PIN, SLAVE_TX_PIN);
          }
        }

        EEPROM.writeUShort(modbus_stop_bit_address, stop_bit_value);  // eeproma yazmaya hazırla

        EEPROM.commit();  // eeproma kaydet

        write_tick_for_stop_bit();

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > two) cursor = one;  // kursoru baştaysa sona döndür
      if (cursor < one) cursor = two;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == one) {
          two_bar(high_light);
          one_bar(low_light);
        } else if (cursor == two) {
          one_bar(high_light);
          two_bar(low_light);
        }
        previous_cursor = cursor;
        write_tick_for_stop_bit();
      }
      break;

    case ethernet:
      break;

    case hart:
      break;

    case profibus:
      break;

    case bluetooth:
      break;

    case wifi:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        WiFi.mode(WIFI_OFF);
        screen_switch = communication;
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        opening_page = true;
        if (cursor == no) {
          screen_switch = communication;
        } else if (cursor == yes) {
          screen_switch = wifi_firmware_uptade;
        }
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(communication_icon, 159, 140, middle_aligned, 91, 90, no, yes);

      if (first_text == true) {
        first_text = false;

        tft.setTextColor(TFT_BLACK, 0xc658);
        if (language == English) {
          tft.setFreeFont(FSS9);
          tft.drawString("To connect, wifi settings must be:", 20, 130);
          tft.drawString("Wifi name: bass", 20, 154);
          tft.drawString("Wifi password: 12345678", 20, 178);
          tft.drawString("Version 2", 20, 202);
        } else if (language == Turkish) {
          tft.setFreeFont(FSS9);
          // tft.drawString("Aby nawiazac polaczenie,", 5, 111);
          // tft.drawString("ustawienia Wi-Fi musza byc nastepujace:", 5, 135);
          // tft.drawString("Nazwa Wi-Fi: bass", 5, 159);
          // tft.drawString("Haslo Wi-Fi: 12345678", 5, 183);
          // tft.drawString("Wersja: 1.2", 5, 207);

          tft.drawString("Baglanmak icin wifi ayarlari su olmalidir:", 20, 130);
          tft.drawString("Wifi adi: bass", 20, 154);
          tft.drawString("Wifi sifre: 12345678", 20, 178);
          tft.drawString("Version 2", 20, 202);
        }
      }

      break;

    case wifi_firmware_uptade:

      if (opening_page == true) {
        opening_page = false;

        tft.fillScreen(0xc658);  // arka planı hafif griye boya

        tft.fillRoundRect(20, 4, 280, 232, 15, TFT_WHITE);  // yumuşak köşeli beyaz zemin hazırla

        WiFi.begin(ssid, password);

        if (language == English) {
          tft.drawString("Connecting to Wi-Fi", 40, 40);
        } else if (language == Turkish) {
          // tft.drawString("Laczenie z siecia Wi-Fi", 40, 40);
          tft.drawString("Wi-Fi'ye baglaniliyor", 40, 40);
        }

        uint8_t connection_counter = 0;
        while (WiFi.status() != WL_CONNECTED) {
          delay(1000);
          tft.drawString(".", 203 + (connection_counter * 10), 40);
          connection_counter++;
          if (connection_counter >= 10) break;
        }

        if (WiFi.status() == WL_CONNECTED) {
          if (language == English) {
            tft.drawString("Wi-Fi connection is successful !", 40, 64);
            tft.drawString("Downloading new firmware ...", 40, 88);
          } else if (language == Turkish) {
            // tft.drawString("Polaczenie Wi-Fi powiodlo sie!", 40, 64);
            // tft.drawString("Sciaganie ...", 40, 88);
            tft.drawString("Wi-Fi baglantisi basarili !", 40, 64);
            tft.drawString("Yeni Firmware indiriliyor ...", 40, 88);
          }

          // Starting OTA Update
          firmwareUpdate();
        } else {
          if (language == English) {
            tft.drawString("Unable to connect to Wi-Fi", 40, 64);

          } else if (language == Turkish) {
            // tft.drawString("Nie udalo sie polaczyc", 40, 64);
            tft.drawString("Wi-Fi'ye baglanilamadi", 40, 64);
          }
          delay(3000);
        }
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        first_text = true;
        screen_switch = wifi;
        break;
      }

      break;

    case display:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = settings;  // ayarlar sayfasına git
        break;
      } else if (button_state == press_enter) {
        button_state = idle;
        screen_switch = cursor;  // kursor nerdeyse o ayara git
        opening_page = true;
        break;
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      bar_select(display_icon, 8, 55, left_aligned, 26, 157, 158, reverse_colors, damping_time);

      break;

    case reverse_colors:

      if (opening_page == true) {
        opening_page = false;
        cursor = dark_theme;
        tft.fillScreen(0xc658);
        white_theme_bar(high_light);
        centered_reverse_colors_bar(high_light);
        dark_theme_bar(low_light);

        write_tick_for_reverse_colors();
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = display;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;

        delete_tick_for_reverse_colors();

        if (cursor == dark_theme) theme_color = dark_theme;
        else if (cursor == white_theme) theme_color = white_theme;

        EEPROM.writeByte(theme_color_address, theme_color);

        EEPROM.commit();  // eeproma kaydet

        write_tick_for_reverse_colors();


      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > white_theme) cursor = dark_theme;  // kursoru baştaysa sona döndür
      if (cursor < dark_theme) cursor = white_theme;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == dark_theme) {
          white_theme_bar(high_light);
          dark_theme_bar(low_light);
        } else if (cursor == white_theme) {
          dark_theme_bar(high_light);
          white_theme_bar(low_light);
        }
        previous_cursor = cursor;
        write_tick_for_reverse_colors();
      }
      break;

    case screen_refresh_time:
      // Case döngüsüne ilk girdiğinde bir kez yapılacaklar
      if (opening_page == true) {
        opening_page = false;

        read_or_write_number = screen_refresh_time_value;

        number_entry_opening_page(read_or_write_number, positive, non_decimal_number);  // Okunan değeri bulunduran değişkeni ekrana basamak basamak yaz

        tft.setFreeFont(FSS12);
        if (language == English) {
          tft.drawString(english[157], 53, 30);  // screen refresh time
          tft.drawString(english[69], 80, 185);  // Range
          tft.drawString("= 0.5 - 4", 157, 185);
        } else if (language == Turkish) {
          tft.drawString(turkish[157], 40, 30);  // ekran yenilenme suresi
          tft.drawString(turkish[69], 78, 185);  // aralık
          tft.drawString("= 0.5 - 4", 145, 185);
        }
        tft.drawString("S", 245, 119);
      }


      // Buton kontrolü
      if (button_state == press_esc) {
        button_state = idle;

        opening_page = true;
        screen_switch = display;
        break;
      } else if (button_state == press_enter) {
        button_state = idle;

        number_entry();  // basamaklardaki rakamları read_or_write_number global değişkenine yazar

        if (read_or_write_number >= 0.5 && read_or_write_number <= 4.0) {  // Girilen sayı aralıktaysa registera yaz range yazısını 1 sn yeşil yap

          screen_refresh_time_value = read_or_write_number;

          EEPROM.writeFloat(screen_refresh_time_value_address, screen_refresh_time_value);

          EEPROM.commit();  // kaydet

          tft.fillRect(80, 163, 150, 18, TFT_WHITE);  // Arka plan temizle
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_DARKGREEN, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[2], 135, 162);  // done !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 80, 185);  // Range
            tft.drawString("= 0.5 - 4", 157, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[2], 112, 162);  // onaylandi !
            tft.setTextColor(TFT_GREY, TFT_WHITE);
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 78, 185);  // Aralik
            tft.drawString("= 0.5 - 4", 145, 185);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        } else {  // Girilen sayı aralıkta değilse registera yazma range yazısını 1 sn kırmızı yap
          tft.setFreeFont(FSSB9);
          tft.setTextColor(TFT_RED, TFT_WHITE);
          if (language == English) {
            tft.drawString(english[73], 105, 162);  // out of range
            tft.setFreeFont(FSS12);
            tft.drawString(english[69], 80, 185);  // Range
            tft.drawString("= 0.5 - 4", 157, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          } else if (language == Turkish) {
            tft.drawString(turkish[73], 95, 162);  // araligin disinda
            tft.setFreeFont(FSS12);
            tft.drawString(turkish[69], 78, 185);  // Aralik
            tft.drawString("= 0.5 - 4", 145, 185);
            tft.setTextColor(TFT_GREY, TFT_WHITE);
          }
          delay(1000);
          tft.drawString("                            ", 75, 162);
        }


      } else if (button_state == press_up) {
        button_state = idle;

        increase_digit_number();
      } else if (button_state == press_down) {
        button_state = idle;
        digit++;
      }
      cursor_movement();  // Basamak altı kısa kırmızı çizginin hareklerini gerçekleştir

      break;

    case damping_time:

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;

        screen_switch = display;

        break;

      } else if (button_state == press_enter) {
        button_state = idle;

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x40, &protect_password);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        uint16_value = cursor - second_1;  // anakarta register hazırlandı yazmak için

        modbus_master.read_or_write(1, WRITE_SINGLE, 0x08, &uint16_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre

        if (uint16_value >= 0 && uint16_value <= 5) tick_location = uint16_value + 1;
        else if (uint16_value >= 6 && uint16_value <= 9) tick_location = uint16_value - 5;

      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (opening_page == true) {
        previous_cursor = 100;
        first_text = true;
        modbus_master.read_or_write(1, READ_HOLDING, 0x08, &uint16_value);
        delay(time_after_communication);  // iki modbus komutu arası beklencek min süre
        if (uint16_value >= 0 && uint16_value <= 5) cursor = second_1;
        else if (uint16_value >= 6 && uint16_value <= 9) cursor = second_16;
      }

      if (cursor < second_1) {
        opening_page = true;
        first_text = true;
        cursor = second_16;
      } else if (cursor > second_60) {
        opening_page = true;
        first_text = true;
        cursor = second_1;
      } else if (cursor == second_10 && previous_cursor == second_16) {
        opening_page = true;
        first_text = true;
      } else if (cursor == second_16 && previous_cursor == second_10) {
        opening_page = true;
        first_text = true;
      }

      if (cursor >= second_1 && cursor <= second_10) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value + 1;
        }

        bar_select(display_icon, 158, 120, middle_aligned, 219, 220, 221, 222, 223, 224, second_1, second_10);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("1/2", 260, 13);
        }

      } else if (cursor >= second_16 && cursor <= second_60) {

        if (opening_page == true) {

          previous_tick_location = 100;
          tick_location = uint16_value - 5;
        }

        bar_select(display_icon, 158, 120, middle_aligned, 225, 226, 227, 228, second_16, second_60);

        if (first_text == true) {
          first_text = false;

          tft.setFreeFont(FSS9);
          tft.setTextColor(TFT_BLACK, TFT_WHITE);
          tft.drawString("2/2", 260, 13);
        }
      }

      break;

    case data_logging:

      if (opening_page == true) {
        opening_page = false;
        cursor = interval_unit;
        tft.fillScreen(0xc658);
        interval_time_bar(high_light);
        centered_data_logging_bar(high_light);
        interval_unit_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = settings;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;
        // screen_switch = cursor;  // kursor nerdeyse o ayara git
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > interval_time) cursor = interval_unit;  // kursoru baştaysa sona döndür
      if (cursor < interval_unit) cursor = interval_time;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == interval_unit) {
          interval_time_bar(high_light);
          interval_unit_bar(low_light);
        } else if (cursor == interval_time) {
          interval_unit_bar(high_light);
          interval_time_bar(low_light);
        }
        previous_cursor = cursor;
      }
      break;

    case information:

      if (opening_page == true) {
        opening_page = false;
        cursor = serial_no;
        tft.fillScreen(0xc658);
        information__bar(high_light);
        product_date_bar(high_light);
        centered_information_bar(high_light);
        serial_no_bar(low_light);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = settings;  // ayarlar sayfasına git
      } else if (button_state == press_enter) {
        button_state = idle;
        if (cursor == _information) {
          screen_switch = _information;
          opening_page = true;
        }
      } else if (button_state == press_up) {
        button_state = idle;
        cursor--;
      } else if (button_state == press_down) {
        button_state = idle;
        cursor++;
      }

      if (cursor > _information) cursor = serial_no;  // kursoru baştaysa sona döndür
      if (cursor < serial_no) cursor = _information;  // kursoru sondaysa başa döndür

      if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
        if (cursor == serial_no) {
          if (previous_cursor == product_date) {
            product_date_bar(high_light);
          } else if (previous_cursor == _information) {
            information__bar(high_light);
          }
          serial_no_bar(low_light);
        } else if (cursor == product_date) {
          if (previous_cursor == serial_no) {
            serial_no_bar(high_light);
          } else if (previous_cursor == _information) {
            information__bar(high_light);
          }
          product_date_bar(low_light);
        } else if (cursor == _information) {
          if (previous_cursor == product_date) {
            product_date_bar(high_light);
          } else if (previous_cursor == serial_no) {
            serial_no_bar(high_light);
          }
          information__bar(low_light);
        }
        previous_cursor = cursor;
      }
      break;

    case _information:

      if (opening_page == true) {
        opening_page = false;
        tft.fillRoundRect(20, 4, 280, 232, 15, TFT_WHITE);  // yumuşak köşeli beyaz zemin hazırla
        tft.setTextColor(TFT_BLACK, TFT_WHITE);
        tft.drawString("EMDE PF", 40, 40);
        tft.drawString("www.bass.com.tr", 40, 88);
        tft.drawString("Tel: 0216 660 01 63 - 64", 40, 136);
        tft.drawString("Istanbul / Turkey", 40, 184);
      }

      if (button_state == press_esc) {
        button_state = idle;
        opening_page = true;
        screen_switch = information;  // ayarlar sayfasına git
        break;
      }

      break;
  }
}

// Kesme içinde timer ile bekleme oluşturma fonksiyonu
void wait(uint32_t ms) {
  unsigned long previous_time = millis();
  while (millis() - previous_time < ms)
    ;
}

// Zamanlama fonksiyonu
void count_second() {

  current_time = millis();                                 // anlık zamanı al
  if (current_time < last_time) last_time = current_time;  // zaman taşması olursa sıfırla

  // Belirlenen sürede girecek
  if (current_time - last_time >= 500) {
    last_time = current_time;  // zamanı güncelle

    half_second++;  // yarım saniyeyi 1 artır
    if (screen_switch == main_screen) conductivity_temperature_second += 0.5;
    else conductivity_temperature_second = 0;

    if (half_second % 2 == 0) {  // saniyede bir giriyor

      time_for_main_sreens++;

      second_for_outputs_set++;

      alarm_time_counter++;

      // Ayarlar ekranı timeout
      if(screen_switch != main_screen) second_for_menu++;
      if(second_for_menu > 60){
        second_for_menu = 0;
        screen_switch = main_screen;
        opening_page = true;
      }

      if (password_validity_time < 120) password_validity_time++;  // şifre geçerlilik süresi başlatıldıysa saniyede 1 artır
      else password_validity_time = 150;                           // geçerlilik süresi bittiyse durdur ya da başlatılmamışsa saydırma
    }
  }
}

// ChatGPT ile oluşturuldu
// Dac çıkışları için eğim hesaplama uyarlama fonksiyonu
float mapFloat(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float read_temperature() {
  const float referenceResistance = 10000;  // 10kΩ sabit direnç
  const float nominalResistance = 10000;    // NTC'nin 25°C'deki nominal direnci
  const float nominalTemperature = 25;      // NTC'nin nominal sıcaklığı (25°C)
  const float bCoefficient = 3950;          // NTC'nin beta katsayısı
  const float seriesResistor = 10000;       // Sabit direnç (10kΩ)
  const float calibrationOffset = -5.5;     // Kalibrasyon faktörü (-x °C çıkararak düzeltme)

  int analogValue = analogRead(NTC_PIN);         // NTC'den analog okuma
  float voltage = analogValue * (3.3 / 4095.0);  // ADC'den voltaj hesapla

  // Direnç hesaplamasını yaparken formülü düzeltiyoruz
  float resistance = (seriesResistor * voltage) / (3.3 - voltage);  // NTC'nin direncini hesapla

  // Steinhart-Hart Denklemi ile sıcaklık hesaplama (Kelvin)
  float steinhart;
  steinhart = resistance / nominalResistance;        // (R/Ro)
  steinhart = log(steinhart);                        // ln(R/Ro)
  steinhart /= bCoefficient;                         // 1/B * ln(R/Ro)
  steinhart += 1.0 / (nominalTemperature + 273.15);  // + (1/To)
  steinhart = 1.0 / steinhart;                       // T = 1/(...)
  steinhart -= 273.15;                               // Kelvin'i Celcius'a çevir

  // Kalibrasyon uygulaması (offset ekleyerek düzeltme)
  steinhart += calibrationOffset;
  if (steinhart > 70) steinhart = 70;
  else if (steinhart < -50) steinhart = -50;
  return steinhart;
}

// ChatGPT ile oluşturuldu
// Doğrusal interpolasyon fonksiyonu
int interpolateMTPToUS(int mtp) {

  // MTP ve uS değerleri için tablolar
  int mtp_values[] = { 2, 5, 6, 9, 11, 25, 36, 56, 69, 85, 107, 148, 2230, 3830, 4230 };
  int us_values[] = { 5440, 4550, 3800, 3200, 2500, 1820, 1375, 911, 762, 631, 500, 368, 20, 10, 0 };

  // Array uzunluğu
  int table_size = sizeof(mtp_values) / sizeof(mtp_values[0]);

  // MTP değeri tablodaki minimumdan küçükse
  if (mtp <= mtp_values[0]) {
    return us_values[0];
  }

  // MTP değeri tablodaki maksimumdan büyükse
  if (mtp >= mtp_values[table_size - 1]) {
    return us_values[table_size - 1];
  }

  // Tablodaki MTP değerleri arasında interpolasyon
  for (int i = 0; i < table_size - 1; i++) {
    if (mtp >= mtp_values[i] && mtp <= mtp_values[i + 1]) {
      int mtp_diff = mtp_values[i + 1] - mtp_values[i];
      int us_diff = us_values[i + 1] - us_values[i];
      int mtp_offset = mtp - mtp_values[i];

      // Doğrusal interpolasyon hesabı
      return us_values[i] + ((us_diff * mtp_offset) / mtp_diff);
    }
  }

  // Eğer bir hata olursa (normalde buraya ulaşılmaması gerekir)
  return -1;
}

int interpolateUSToMTP(int us) {

  // MTP ve uS değerleri için tablolar
  int mtp_values[] = { 2, 5, 6, 9, 11, 25, 36, 56, 69, 85, 107, 148, 2230, 3830, 4230 };
  int us_values[] = { 5440, 4550, 3800, 3200, 2500, 1820, 1375, 911, 762, 631, 500, 368, 20, 10, 0 };

  // Array uzunluğu
  int table_size = sizeof(mtp_values) / sizeof(mtp_values[0]);

  // uS değeri tablodaki maksimumdan büyükse
  if (us >= us_values[0]) {
    return mtp_values[0];
  }

  // uS değeri tablodaki minimumdan küçükse
  if (us <= us_values[table_size - 1]) {
    return mtp_values[table_size - 1];
  }

  // Tablodaki uS değerleri arasında interpolasyon
  for (int i = 0; i < table_size - 1; i++) {
    if (us <= us_values[i] && us >= us_values[i + 1]) {
      int us_diff = us_values[i] - us_values[i + 1];
      int mtp_diff = mtp_values[i + 1] - mtp_values[i];
      int us_offset = us_values[i] - us;

      // Doğrusal interpolasyon hesabı
      return mtp_values[i] + ((mtp_diff * us_offset) / us_diff);
    }
  }

  // Eğer bir hata olursa (normalde buraya ulaşılmaması gerekir)
  return -1;
}

void modbus_rx() {

  if (register_adress != 10000) {

    // yazma isteği gelirse
    if (register_adress == 0) {

      // modbus_slave.read_from_holding_registers(holdingRegisters, &flow_range_value, flow_range_value_address);

      // modbus_master.read_or_write(1, WRITE_MULTI, 261, &flow_range_value);
    }

    register_adress = 10000;
  }
}

void IRAM_ATTR serial_interrupt() {

  if (Serial.available()) {
    register_adress = modbus_slave.poll();
  }
}

void IRAM_ATTR esc_button_interrupt() {

  uint32_t now = millis();
  int lvl = digitalRead(esc_button);

  if (lvl == LOW) {  // basış
    if (now < quiet_until) return;
    if (esc_locked) return;
    if (now - esc_tedge < DEBOUNCE_MS) return;
    if (pin_low(esc_button) && pin_low(esc_button)) {
      esc_count++;
      esc_locked = true;
      esc_tedge = now;
      quiet_until = now + QUIET_MS;
      button_state = press_esc;
      second_for_menu = 0;
      if (password_validity_time != 150) password_validity_time = 0;
    }
    return;
  }
  // bırakış
  if (esc_locked) {
    if (now - esc_tedge < DEBOUNCE_MS) return;
    if (pin_high(esc_button) && pin_high(esc_button)) {
      esc_locked = false;
      esc_tedge = now;
    }
  }
}

void IRAM_ATTR up_button_interrupt() {

  uint32_t now = millis();
  int lvl = digitalRead(up_button);

  if (lvl == LOW) {
    if (now < quiet_until) return;
    if (up_locked) return;
    if (now - up_tedge < DEBOUNCE_MS) return;
    if (pin_low(up_button) && pin_low(up_button)) {
      up_count++;
      up_locked = true;
      up_tedge = now;
      quiet_until = now + QUIET_MS;
      button_state = press_up;
      second_for_menu = 0;
      if (password_validity_time != 150) password_validity_time = 0;
    }
    return;
  }
  if (up_locked) {
    if (now - up_tedge < DEBOUNCE_MS) return;
    if (pin_high(up_button) && pin_high(up_button)) {
      up_locked = false;
      up_tedge = now;
    }
  }
}

void IRAM_ATTR down_button_interrupt() {
  uint32_t now = millis();
  int lvl = digitalRead(down_button);

  if (lvl == LOW) {
    if (now < quiet_until) return;
    if (down_locked) return;
    if (now - down_tedge < DEBOUNCE_MS) return;
    if (pin_low(down_button) && pin_low(down_button)) {
      down_count++;
      down_locked = true;
      down_tedge = now;
      quiet_until = now + QUIET_MS;
      button_state = press_down;
      second_for_menu = 0;
      if (password_validity_time != 150) password_validity_time = 0;
    }
    return;
  }
  if (down_locked) {
    if (now - down_tedge < DEBOUNCE_MS) return;
    if (pin_high(down_button) && pin_high(down_button)) {
      down_locked = false;
      down_tedge = now;
    }
  }
}

void IRAM_ATTR enter_button_interrupt() {

  uint32_t now = millis();
  int lvl = digitalRead(enter_button);

  if (lvl == LOW) {
    if (now < quiet_until) return;
    if (enter_locked) return;
    if (now - enter_tedge < DEBOUNCE_MS) return;
    if (pin_low(enter_button) && pin_low(enter_button)) {
      enter_count++;
      enter_locked = true;
      enter_tedge = now;
      quiet_until = now + QUIET_MS;
      button_state = press_enter;
      second_for_menu = 0;
      if (password_validity_time != 150) password_validity_time = 0;
    }
    return;
  }
  if (enter_locked) {
    if (now - enter_tedge < DEBOUNCE_MS) return;
    if (pin_high(enter_button) && pin_high(enter_button)) {
      enter_locked = false;
      enter_tedge = now;
    }
  }
}
/*******************************************************************************************************************************************/


/*******************************************************************************************************************************************/
// ANA EKRAN FONKSİYONLARI

void bar_graph_new(uint16_t x, uint8_t y, uint16_t percentage_value, uint16_t first_color, uint16_t second_color, uint16_t frame_color) {

  if (theme_color == dark_theme) {
    tft.fillRectVGradient(x + (percentage_value * 2.8), y, 280 - (percentage_value * 2.8), 20, 0x2124, 0x2124);  // Bar ic kısım silmek için siyahla doldurur
    tft.setTextColor(TFT_WHITE, 0x2124);
    tft.fillRectVGradient(x, y, percentage_value * 2.8, 20, first_color, second_color);  // Bar ic renkli dolgusu
  } else {
    tft.fillRectVGradient(x + (percentage_value * 2.8), y, 280 - (percentage_value * 2.8), 20, TFT_WHITE, TFT_WHITE);  // Bar ic kısım silmek için beyazla doldurur
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
    tft.fillRectVGradient(x, y, percentage_value * 2.8, 20, first_color, second_color);  // Bar ic renkli dolgusu
  }

  if (percentage_value < 100 && percentage_value > 0) {
    tft.drawWideLine(x + percentage_value * 2.8 - 1, y, x + percentage_value * 2.8 - 1, y + 19, 2, TFT_RED, TFT_RED);  // Bar kırmızı cizgi
  }

  tft.drawRoundRect(x - 1, y - 1, 282, 22, 4, frame_color);  // Bar cercevesi

  // Bar cizgileri
  tft.drawLine(x + 13, y + 8, x + 13, y + 19, frame_color);
  tft.drawLine(x + 28, y + 8, x + 28, y + 19, frame_color);
  tft.drawLine(x + 43, y + 8, x + 43, y + 19, frame_color);
  tft.drawLine(x + 56, y + 8, x + 56, y + 19, frame_color);
  tft.drawLine(x + 69, y + 4, x + 69, y + 19, frame_color);  // uzun çizgi
  tft.drawLine(x + 83, y + 8, x + 83, y + 19, frame_color);
  tft.drawLine(x + 97, y + 8, x + 97, y + 19, frame_color);
  tft.drawLine(x + 111, y + 8, x + 111, y + 19, frame_color);
  tft.drawLine(x + 125, y + 8, x + 125, y + 19, frame_color);
  tft.drawLine(x + 140, y + 4, x + 140, y + 19, frame_color);  // uzun çizgi
  tft.drawLine(x + 153, y + 8, x + 153, y + 19, frame_color);
  tft.drawLine(x + 168, y + 8, x + 168, y + 19, frame_color);
  tft.drawLine(x + 181, y + 8, x + 181, y + 19, frame_color);
  tft.drawLine(x + 196, y + 8, x + 196, y + 19, frame_color);
  tft.drawLine(x + 209, y + 4, x + 209, y + 19, frame_color);  // uzun çizgi
  tft.drawLine(x + 223, y + 8, x + 223, y + 19, frame_color);
  tft.drawLine(x + 237, y + 8, x + 237, y + 19, frame_color);
  tft.drawLine(x + 251, y + 8, x + 251, y + 19, frame_color);
  tft.drawLine(x + 265, y + 8, x + 265, y + 19, frame_color);

  // Bar yuzde sayıları
  tft.setFreeFont(FSS9);
  tft.setTextColor(TFT_NAVY, TFT_WHITE);
  tft.drawString("0", x - 2, y + 28);
  // tft.drawString("25", x + 62, y + 28, FONT2);
  tft.drawString("50", x + 132, y + 28);
  // tft.drawString("75", x + 202, y + 28, FONT2);
  tft.drawString("100", x + 262, y + 28);
}

// Sigma işareti (toplam gösterimleri için)
void draw_sigma(uint16_t x, uint8_t y, uint16_t color) {

  tft.drawWideLine(x + 13, y, x, y, 2, color, color);
  tft.drawWideLine(x + 10, y + 10, x, y, 2, color, color);
  tft.drawWideLine(x, y + 20, x + 10, y + 10, 2, color, color);
  tft.drawWideLine(x + 13, y + 20, x, y + 20, 2, color, color);
}

// Açılış logo animasyonu
void beginning_logo_animation() {

  tft.pushImage(0, 0, 320, 240, better_solution);
  delay(7000);

  tft.fillScreen(TFT_BLACK);

  tft.pushImage(97, 52, 126, 137, bass_logo_kucuk);
  delay(7000);
}
/*******************************************************************************************************************************************/


/*******************************************************************************************************************************************/
// AYARLAR EKRANI FONKSİYONLARI

// Sayı giriş ekranı açılış fonksiyonu
void number_entry_opening_page(double read_number, bool sign, bool decimal) {

  char string_read_number[15];        // 7 basamak + 1 null karakter için yer ayrıldı
  sign_digit = sign;                  // fonksiyonda girilen işaret durumunu farklı fonksiyonlarda kullanmak için global değişkene ata
  decimal_state = decimal;            // okunan registerdaki sayının tam mı noktalı mı olduğunu tutar
  memset(number, 0, sizeof(number));  // Basamaklardaki rakamları sıfırla

  tft.fillScreen(0xc658);
  tft.fillRoundRect(20, 4, 280, 232, 15, TFT_WHITE);
  tft.drawWideLine(260, 70, 60, 70, 4, TFT_RED, TFT_RED);  // uzun kırmızı çizgi
  tft.setTextColor(TFT_GREY, TFT_WHITE);
  tft.setFreeFont(FSS18);

  // İşaretli sayıysa işaret koy değilse koyma
  if (sign == true) {
    digit = 0;  // yanıp sönen imleç dijit konumu
    if (read_number >= 0) {
      tft.drawString("+", 35, 101);
      sign_state = true; //sayı işaretsizse pozitif olarak ayarla
    } else {
      tft.drawWideLine(51, 119, 38, 119, 3, TFT_GREY, TFT_GREY);  // - işareti
      sign_state = false;                                         //sayı negatif bilgisi
    }
  } else {
    digit = 1;          // yanıp sönen imleç dijit konumunu en soldaki rakamdan başlat
    sign_state = true;  //sayı işaretsizse pozitif olarak ayarla
  }
  if (read_number < 0) read_number = read_number * -1;  // okunan sayı negatifse pozitif yap

  tft.setFreeFont(FSS24);

  // Okunan sayıya göre nokta konumunu ayarla
  if (read_number >= 100000) {
    sprintf(string_read_number, "%07.0f", read_number);
    write_as_character(string_read_number, read_number);
  } else if (read_number < 100000 && read_number >= 10000) {
    sprintf(string_read_number, "%07.1f", read_number);
    write_as_character(string_read_number, read_number);
  } else if (read_number < 10000 && read_number >= 1000) {
    sprintf(string_read_number, "%07.2f", read_number);
    write_as_character(string_read_number, read_number);
  } else if (read_number < 1000 && read_number >= 100) {
    sprintf(string_read_number, "%07.3f", read_number);
    write_as_character(string_read_number, read_number);
  } else if (read_number < 100 && read_number >= 10) {
    sprintf(string_read_number, "%07.4f", read_number);
    write_as_character(string_read_number, read_number);
  } else if (read_number < 10) {
    sprintf(string_read_number, "%07.5f", read_number);
    write_as_character(string_read_number, read_number);
  }
}

// Sayı giriş ekranındaki basamakları belirlenen bir double registerda topla
// Artı eksi durumunu, noktalı noktasız, 7 basamağa kadar girilen sayıyı bir double girildiği yazar
void number_entry() {
  uint8_t divider = 0;       // sayı ondalıksa nokta konumu
  read_or_write_number = 0;  // önceki girilen sayıyı temizle

  // Basamaklardaki ayrı rakamlarları tek bir değişkende topla
  for (uint8_t digit_count = 1; digit_count < 8; digit_count++) {

    if (number[digit_count] == 10) divider = digit_count;  // Sayı ondalıklıysa noktanın konumunu kaydet

    if (number[digit_count] != 0 && number[digit_count] != 10) {  // basamaklardaki 0 ve . karakterlerini (10 nokta karakterinin karşılığı olarak registerda tutuyor)
      if (divider != 0) {
        read_or_write_number = read_or_write_number + number[digit_count] * pow(10, (8 - digit_count));  // sayıda nokta varsa hesaplamayı doğru yapmak için noktadan sonraki basamakları ilave 10 ile çarp
      } else {
        read_or_write_number = read_or_write_number + number[digit_count] * pow(10, (7 - digit_count));  // sayı max 7 basamaklı olduğu için on üzeri yedi den geriye düşerek hesaplama yapılıyor
      }
    }
  }

  // Sayı ondalıksa noktasını koy
  if (divider != 0) {
    read_or_write_number = read_or_write_number / pow(10, (8 - divider));
  }

  if (sign_state == false) read_or_write_number = read_or_write_number * -1;  // Sayı negatifse değişkenini negatife çevir
}

void cursor_movement() {
  static bool red_line_short = true;  // red line çizilimi kontrol değişkeni
  static uint8_t previous_half_second;

  // Sayı altı kırmızı imleç konum değiştir
  if (digit != previous_digit) {
    previous_half_second = 0;
    half_second = 1;
    red_line_short = false;
    if (digit > 7) {
      if (sign_digit == true) digit = 0;  // sayı işaretli ise işaret basamağından başla
      else digit = 1;
    }
    tft.drawWideLine(57 + previous_digit * 25, 147, 34 + previous_digit * 25, 147, 4, TFT_WHITE, TFT_WHITE);
    previous_digit = digit;
  }

  // Sayı altı kırmızı imleç var yok animasyon
  if (half_second != previous_half_second) {
    if (red_line_short == true) {  // red line çizilimi
      tft.drawWideLine(57 + digit * 25, 147, 34 + digit * 25, 147, 4, TFT_RED, TFT_RED);
    } else {
      tft.drawWideLine(57 + digit * 25, 147, 34 + digit * 25, 147, 4, TFT_WHITE, TFT_WHITE);
    }
    red_line_short = !red_line_short;
    previous_half_second = half_second;
  }
}

// Girilen string sayıyı, sayı giriş ekranına karakter karakter bastır
void write_as_character(char string[], double read_number) {
  tft.setTextColor(TFT_GREY, TFT_WHITE);
  // Okunan sayının sağındaki sıfırları sola yazdır
  int8_t number_of_zero = 0, digit_count;
  if (read_number < 100000) {
    for (digit_count = 6; digit_count >= 0; digit_count--) {
      if (string[digit_count] == '0' || string[digit_count] == '\.') {

        if (read_number >= 1000 && read_number < 10000) {
          if (fixed_digit == number_of_zero + 4) break;
        } else if (read_number >= 100 && read_number < 1000) {
          if (fixed_digit == number_of_zero + 3) break;
        } else if (read_number >= 10 && read_number < 100) {
          if (fixed_digit == number_of_zero + 2) break;
        } else if (read_number < 10) {
          if (fixed_digit == number_of_zero + 1) break;
        }

        tft.drawString("0", 58 + number_of_zero * 25, 100);
        number_of_zero++;
        if (string[digit_count] == '\.') break;
      } else break;
    }
  }

  // Okunan sayının sağındaki sıfır kadar sağa ötele
  for (digit_count = 0; digit_count < strlen(string) - number_of_zero; digit_count++) {
    char char_buffer[2];
    char_buffer[0] = string[digit_count];
    char_buffer[1] = '\0';
    if (char_buffer[0] == '\.') {  // nokta karakterini boşluğuna ortala
      tft.drawString(char_buffer, 65 + (digit_count + number_of_zero) * 25, 100);
      number[digit_count + number_of_zero + 1] = 10;  // okunan sayıyıdaki noktayı basamağa yaz
    } else {
      tft.drawString(char_buffer, 58 + (digit_count + number_of_zero) * 25, 100);
      number[digit_count + number_of_zero + 1] = char_buffer[0] - '0';  // okunan sayıyı basamaklara yaz
    }
  }
}

// Digite karakteri yaz
void write_in_digit(int8_t *entered_number) {

  char char_buffer[2];
  uint8_t number_of_point = 0;

  if (*entered_number < 10) {  // 0 - 9 arasını direkt ekrana yaz
    sprintf(char_buffer, "%d", *entered_number);
  } else if (*entered_number == 10) {  // 9 dan sonra nokta karakteri olarak yaz
    if (decimal_state == false) {
      for (uint8_t digit_count = 1; digit_count < 8; digit_count++) {
        if (number[digit_count] == 10) number_of_point++;
      }

      if (number_of_point > 1 || digit == 1 || digit == 7) {  // Diğer basamaklarda nokta varsa bulunulan basamağa nokta yazma. İlk ve son basamağa da nokta yazma
        *entered_number = 0;
        sprintf(char_buffer, "%d", *entered_number);
      } else {  // Basamaklardan herhangi birinde nokta yoksa o basağa nokta koyabilirsin
        char_buffer[0] = '\.';
        char_buffer[1] = '\0';
      }
    } else {
      *entered_number = 0;
      sprintf(char_buffer, "%d", *entered_number);
    }

  } else if (*entered_number == 11) {  // nokta karakterinden sonra tekrar 0 dan başlat
    *entered_number = 0;
    sprintf(char_buffer, "%d", *entered_number);
  }

  tft.fillRect((digit * 25) + 34, 101, 24, 35, TFT_WHITE);  // Sayı yazmadan önce arka planı temizle

  if (char_buffer[0] == '\.') {  // nokta karakteri varsa, o basamakta boşluğuna ortala
    tft.drawString(char_buffer, 40 + digit * 25, 100);
  } else {
    tft.drawString(char_buffer, 34 + digit * 25, 100);
  }
}

// İmleç hangi basamaktaysa onun rakamını artır
void increase_digit_number() {

  tft.setFreeFont(FSS24);
  if (digit == 0) {
    sign_state = !sign_state;                                 // okunan sayıda pozitif negatif işareti varsa göster yoksa gösterme
    tft.fillRect((digit * 25) + 34, 101, 24, 35, TFT_WHITE);  // İşaret yazmadan önce arka planı temizle
    if (sign_state) {
      tft.setFreeFont(FSS18);
      tft.drawString("+", 35, 101);
    } else {
      tft.drawWideLine(51, 119, 38, 119, 3, TFT_GREY, TFT_GREY);  // - işareti
    }
  } else if (digit == 1) {
    number[1]++;
    write_in_digit(&number[1]);
  } else if (digit == 2) {
    number[2]++;
    write_in_digit(&number[2]);
  } else if (digit == 3) {
    number[3]++;
    write_in_digit(&number[3]);
  } else if (digit == 4) {
    number[4]++;
    write_in_digit(&number[4]);
  } else if (digit == 5) {
    number[5]++;
    write_in_digit(&number[5]);
  } else if (digit == 6) {
    number[6]++;
    write_in_digit(&number[6]);
  } else if (digit == 7) {
    number[7]++;
    write_in_digit(&number[7]);
  }
}

// Şifre giriş ekranı için özel sayı yazma fonksiyonu (sayı altındaki fazlalık arka plan rengini temizler)
void draw_char(uint8_t entered_number, uint16_t x, uint16_t y, uint16_t fgcolor, uint16_t bgcolor) {
  tft.setFreeFont(FSSB24);
  tft.setTextColor(fgcolor, bgcolor);
  tft.drawNumber(entered_number, x, y);
  tft.fillRect(x, y + 39, 27, 10, TFT_BLACK);
}

// Büyüktür çizgisi
void draw_greather_than(uint16_t x, uint8_t y, uint16_t color) {
  tft.drawWideLine(x + 6, y + 6, x, y, 1, color, color);
  tft.drawWideLine(x, y + 12, x + 6, y + 6, 1, color, color);
}

// Yeşil tick işareti
void draw_tick(uint16_t x, uint8_t y, uint16_t color) {
  tft.drawWideLine(x + 11, y + 13, x + 4, y + 7, 2, color, color);   // kısa çizgi
  tft.drawWideLine(x + 21, y - 6, x + 11, y + 13, 2, color, color);  // uzun çizgi
}



/**
    * @brief Tik işareti koyan ya da silen fonksiyonlardır, global değişken olan tick location un durumuna göre barlarda tick oluşturur ve ya siler
    * @param tick_position_x Tick işaretinin x koordinatında başlama hizasıdır. Önerilen yazı başlangıcından 35 az olmasıdır
    */

void write_tick(uint16_t tick_position_x) {
  if (tick_location == 1) {
    draw_tick(tick_position_x, 50, TFT_DARKGREEN);
  } else if (tick_location == 2) {
    draw_tick(tick_position_x, 83, TFT_DARKGREEN);
  } else if (tick_location == 3) {
    draw_tick(tick_position_x, 116, TFT_DARKGREEN);
  } else if (tick_location == 4) {
    draw_tick(tick_position_x, 149, TFT_DARKGREEN);
  } else if (tick_location == 5) {
    draw_tick(tick_position_x, 182, TFT_DARKGREEN);
  } else if (tick_location == 6) {
    draw_tick(tick_position_x, 215, TFT_DARKGREEN);
  }
}

void delete_tick(uint16_t tick_position_x) {
  if (previous_tick_location == 1) {
    draw_tick(tick_position_x, 50, TFT_WHITE);
  } else if (previous_tick_location == 2) {
    draw_tick(tick_position_x, 83, TFT_WHITE);
  } else if (previous_tick_location == 3) {
    draw_tick(tick_position_x, 116, TFT_WHITE);
  } else if (previous_tick_location == 4) {
    draw_tick(tick_position_x, 149, TFT_WHITE);
  } else if (previous_tick_location == 5) {
    draw_tick(tick_position_x, 182, TFT_WHITE);
  } else if (previous_tick_location == 6) {
    draw_tick(tick_position_x, 215, TFT_WHITE);
  }
}

void write_tick_for_baud_rate() {
  if (baud_rate_value == 1200) {
    draw_tick(105, 50, TFT_DARKGREEN);
  } else if (baud_rate_value == 2400) {
    draw_tick(105, 83, TFT_DARKGREEN);
  } else if (baud_rate_value == 4800) {
    draw_tick(105, 116, TFT_DARKGREEN);
  } else if (baud_rate_value == 9600) {
    draw_tick(105, 149, TFT_DARKGREEN);
  } else if (baud_rate_value == 19200) {
    draw_tick(105, 182, TFT_DARKGREEN);
  } else if (baud_rate_value == 38400) {
    draw_tick(105, 215, TFT_DARKGREEN);
  }
}

void write_tick_for_parity_bit() {
  if (parity_bit_value == 0) {
    draw_tick(105, 50, TFT_DARKGREEN);
  } else if (parity_bit_value == 1) {
    draw_tick(105, 83, TFT_DARKGREEN);
  } else if (parity_bit_value == 2) {
    draw_tick(105, 116, TFT_DARKGREEN);
  }
}

void delete_tick_for_parity_bit() {
  if (parity_bit_value == 0) {
    draw_tick(105, 50, TFT_WHITE);
  } else if (parity_bit_value == 1) {
    draw_tick(105, 83, TFT_WHITE);
  } else if (parity_bit_value == 2) {
    draw_tick(105, 116, TFT_WHITE);
  }
}

void write_tick_for_stop_bit() {
  if (stop_bit_value == 1) {
    draw_tick(120, 50, TFT_DARKGREEN);
  } else if (stop_bit_value == 2) {
    draw_tick(120, 83, TFT_DARKGREEN);
  }
}

void delete_tick_for_stop_bit() {
  if (stop_bit_value == 1) {
    draw_tick(120, 50, TFT_WHITE);
  } else if (stop_bit_value == 2) {
    draw_tick(120, 83, TFT_WHITE);
  }
}

void write_tick_for_analog_out_2_type() {
  if (analog_out_2_type == _ma_4_20) {
    draw_tick(76, 50, TFT_DARKGREEN);
  } else if (analog_out_2_type == _ma_4_12_20) {
    draw_tick(76, 83, TFT_DARKGREEN);
  }
}

void delete_tick_for_analog_out_2_type() {
  if (analog_out_2_type == _ma_4_20) {
    draw_tick(76, 50, TFT_WHITE);
  } else if (analog_out_2_type == _ma_4_12_20) {
    draw_tick(76, 83, TFT_WHITE);
  }
}

void write_tick_for_analog_out_3_type() {
  if (analog_out_3_type == v_0_10) {
    draw_tick(76, 50, TFT_DARKGREEN);
  } else if (analog_out_3_type == v_0_5_10) {
    draw_tick(76, 83, TFT_DARKGREEN);
  }
}

void delete_tick_for_analog_out_3_type() {
  if (analog_out_3_type == v_0_10) {
    draw_tick(76, 50, TFT_WHITE);
  } else if (analog_out_3_type == v_0_5_10) {
    draw_tick(76, 83, TFT_WHITE);
  }
}

void write_tick_for_analog_out_2_test() {
  if (analog_out_2_type == ma_4) {
    draw_tick(76, 50, TFT_DARKGREEN);
  } else if (analog_out_2_type == ma_12) {
    draw_tick(76, 83, TFT_DARKGREEN);
  } else if (analog_out_2_type == ma_20) {
    draw_tick(76, 116, TFT_DARKGREEN);
  }
}

void delete_tick_for_analog_out_2_test() {
  if (analog_out_2_type == ma_4) {
    draw_tick(76, 50, TFT_WHITE);
  } else if (analog_out_2_type == ma_12) {
    draw_tick(76, 83, TFT_WHITE);
  } else if (analog_out_2_type == ma_20) {
    draw_tick(76, 116, TFT_WHITE);
  }
}

void write_tick_for_pulse_freqency() {
  if (digital_out_selection == 1) {
    draw_tick(40, 50, TFT_DARKGREEN);
  } else if (digital_out_selection == 0) {
    draw_tick(40, 83, TFT_DARKGREEN);
  }
}

void delete_tick_for_pulse_freqency() {
  if (digital_out_selection == 1) {
    draw_tick(40, 50, TFT_WHITE);
  } else if (digital_out_selection == 0) {
    draw_tick(40, 83, TFT_WHITE);
  }
}

void write_tick_for_reverse_colors() {
  if (theme_color == dark_theme) {
    draw_tick(80, 50, TFT_DARKGREEN);
  } else {
    draw_tick(80, 83, TFT_DARKGREEN);
  }
}

void delete_tick_for_reverse_colors() {
  if (theme_color == dark_theme) {
    draw_tick(80, 50, TFT_WHITE);
  } else {
    draw_tick(80, 83, TFT_WHITE);
  }
}


// Basic settings menü barları
void centered_language_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 243, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[15], 140, 13);
    tft.pushImage(100, 7, 27, 26, basic_settings_icon);
  } else if (language == Turkish) {
    tft.drawString(turkish[15], 160, 13);
    tft.pushImage(120, 7, 27, 26, basic_settings_icon);
  }
}

void centered_units_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[109], 105, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[109], 105, 13);
  }
  tft.pushImage(65, 7, 27, 26, basic_settings_icon);
}

void flow_unit_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 48, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[32], 45, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[32], 45, 46);
  }
}

void total_unit_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 81, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[110], 45, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[110], 45, 79);
  }
}

void english_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 243, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[78], 134, 46);
  } else if (language == Turkish) {
    tft.drawString(english[78], 134, 46);
  }
}

void turkish_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(turkish[79], 134, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[79], 134, 79);
  }
}


// Advanced settings menü barları
void centered_total_forward_reset_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[96], 94, 13);
    tft.pushImage(57, 7, 27, 26, advanced_setting_icon);

  } else if (language == Turkish) {
    tft.drawString(turkish[96], 106, 13);
    tft.pushImage(69, 7, 27, 26, advanced_setting_icon);
  }
}

void centered_total_reverse_reset_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[97], 90, 13);
    tft.pushImage(53, 7, 27, 26, advanced_setting_icon);

  } else if (language == Turkish) {
    tft.drawString(turkish[97], 106, 13);
    tft.pushImage(69, 7, 27, 26, advanced_setting_icon);
  }
}

void no_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 243, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[91], 147, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[91], 134, 46);
  }
}

void yes_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[90], 143, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[90], 140, 79);
  }
}


// Output menü barları
void centered_analog_output_2_mA_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[83], 104, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[83], 104, 13);
  }
  tft.pushImage(67, 7, 27, 26, output_icon);
}

void centered_analog_output_3_VDC_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[101], 100, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[101], 100, 13);
  }
  tft.pushImage(64, 7, 27, 26, output_icon);
}

void centered_digital_output_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[25], 117, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[25], 117, 13);
  }
  tft.pushImage(80, 7, 27, 26, output_icon);
}

void centered_funciton_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 245, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[47], 135, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[47], 135, 13);
  }
  tft.pushImage(98, 7, 27, 26, output_icon);
}

void centered_output_type_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[84], 117, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[84], 117, 13);
  }
  tft.pushImage(80, 7, 27, 26, output_icon);
}

void centered_test_mode_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[102], 117, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[102], 117, 13);
  }
  tft.pushImage(80, 7, 27, 26, output_icon);
}

void centered_output_calibration_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 245, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[103], 104, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[103], 104, 13);
  }
  tft.pushImage(67, 7, 27, 26, output_icon);
}

void centered_pulse_frequency_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[61], 105, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[61], 105, 13);
  }
  tft.pushImage(68, 7, 27, 26, output_icon);
}

void ma_4_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 245, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 245, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString(units[30], 130, 46);
}

void ma_12_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 245, 70, TFT_SHADOW);
  tft.drawLine(75, 103, 245, 103, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString(units[31], 130, 79);
}

void ma_20_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 103, 245, 103, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString(units[32], 130, 112);
}

void function_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 48, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[47], 45, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[47], 45, 46);
  }
}

void output_type_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  draw_greather_than(268, 81, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[84], 45, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[84], 45, 79);
  }
}

void test_mode_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 103, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 103, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  draw_greather_than(268, 114, TFT_SILVER);

  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  tft.drawLine(75, 136, 300, 136, TFT_SHADOW);

  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[102], 45, 112);
  } else if (language == Turkish) {
    tft.drawString(turkish[102], 45, 112);
  }
}

void output_calibration_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 136, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 136, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 136, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 136, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 136, 300, 136, TFT_SHADOW);
  draw_greather_than(268, 147, TFT_SILVER);

  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[103], 45, 145);
  } else if (language == Turkish) {
    tft.drawString(turkish[103], 45, 145);
  }
}

void flow_type_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 245, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 245, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[85], 110, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[85], 110, 46);
  }
}

void temperature_type_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 245, 70, TFT_SHADOW);
  tft.drawLine(75, 103, 245, 103, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[86], 110, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[86], 110, 79);
  }
}

void conductivity_type_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 103, 245, 103, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[87], 110, 112);
  } else if (language == Turkish) {
    tft.drawString(turkish[87], 110, 112);
  }
}

void adjust_4_ma_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 48, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[104], 45, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[104], 45, 46);
  }
}

void adjust_20_ma_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 81, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[105], 45, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[105], 45, 79);
  }
}

void adjust_0_V_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 48, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[106], 45, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[106], 45, 46);
  }
}

void adjust_10_V_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 81, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[107], 45, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[107], 45, 79);
  }
}

void v_0_10_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 243, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString(english[53], 125, 46);
}

void v_0_5_10_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);

  tft.drawString(units[29], 115, 79);
}

void v_5_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 243, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString(units[33], 145, 46);
}

void v_10_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);

  tft.drawString(units[34], 135, 79);
}

void _ma_4_20_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 243, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString(english[54], 125, 46);
}

void _ma_4_12_20_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);

  tft.drawString(english[60], 115, 79);
}

void digital_out_1_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 48, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[55], 45, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[55], 45, 46);
  }
}

void digital_out_2_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  draw_greather_than(268, 81, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[56], 45, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[56], 45, 79);
  }
}

void digital_out_3_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  draw_greather_than(268, 114, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[57], 45, 112);
  } else if (language == Turkish) {
    tft.drawString(turkish[57], 45, 112);
  }
}

void pulse_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[67], 75, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[67], 75, 46);
  }
}

void frequency_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[68], 75, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[68], 75, 79);
  }
}


// Communication menü barları
void centered_modbus_baudrate_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[50], 102, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[50], 102, 13);
  }
  tft.pushImage(65, 7, 27, 26, communication_icon);
}

void centered_modbus_parity_bit_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[52], 97, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[52], 90, 13);
  }
  tft.pushImage(60, 7, 27, 26, communication_icon);
}

void centered_modbus_stop_bit_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[98], 100, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[98], 90, 13);
  }
  tft.pushImage(63, 7, 27, 26, communication_icon);
}

void centered_modbus_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[40], 140, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[40], 145, 13);
  }
  tft.pushImage(103, 7, 27, 26, communication_icon);
}

void modbus_baudrate_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 48, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[50], 45, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[50], 45, 46);
  }
}

void modbus_ID_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  draw_greather_than(268, 81, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[51], 45, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[51], 45, 79);
  }
}

void modbus_parity_bit_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 103, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 103, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  draw_greather_than(268, 114, TFT_SILVER);

  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  tft.drawLine(75, 136, 300, 136, TFT_SHADOW);

  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[52], 45, 112);
  } else if (language == Turkish) {
    tft.drawString(turkish[52], 45, 112);
  }
}

void modbus_stop_bit_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 136, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 136, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 136, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 136, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 136, 300, 136, TFT_SHADOW);
  draw_greather_than(268, 147, TFT_SILVER);

  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[98], 45, 145);
  } else if (language == Turkish) {
    tft.drawString(turkish[98], 45, 145);
  }
}

void one_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 243, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString("1", 160, 46);
}

void two_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString("2", 160, 79);
}

void baud_1200_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 243, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString("1200", 139, 46);
}

void baud_2400_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 245, 70, TFT_SHADOW);
  tft.drawLine(75, 103, 245, 103, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString("2400", 140, 79);
}

void baud_4800_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 103, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 103, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 103, 245, 103, TFT_SHADOW);
  tft.drawLine(75, 136, 245, 136, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString("4800", 140, 112);
}

void baud_9600_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 136, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 136, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 136, 245, 136, TFT_SHADOW);
  tft.drawLine(75, 169, 245, 169, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString("9600", 140, 145);
}

void baud_19200_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 169, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 169, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 169, 245, 169, TFT_SHADOW);
  tft.drawLine(75, 202, 245, 202, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString("19200", 135, 178);
}

void baud_38400_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 202, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 202, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 202, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 202, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 202, 245, 202, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  tft.drawString("38400", 136, 211);
}

void none_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 243, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[70], 138, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[70], 138, 46);
  }
}

void odd_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 245, 70, TFT_SHADOW);
  tft.drawLine(75, 103, 245, 103, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[71], 138, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[71], 138, 79);
  }
}

void even_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 103, 245, 103, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[72], 138, 112);
  } else if (language == Turkish) {
    tft.drawString(turkish[72], 138, 112);
  }
}


// Display menü barları
void centered_reverse_colors_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(63, 37, 257, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[26], 115, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[26], 115, 13);
  }
  tft.pushImage(78, 7, 27, 26, display_icon);
}

void dark_theme_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(63, 37, 257, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[99], 120, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[99], 120, 46);
  }
}

void white_theme_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 243, 70, TFT_SHADOW);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[100], 120, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[100], 120, 79);
  }
}


// Data logging menü barları
void centered_data_logging_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[9], 117, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[9], 117, 13);
  }
  tft.pushImage(80, 7, 27, 26, data_logging_icon);
}

void interval_unit_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 48, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[38], 45, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[38], 45, 46);
  }
}

void interval_time_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 70, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 81, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[39], 45, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[39], 45, 79);
  }
}


// Information menü barları
void centered_information_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 4, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 23, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.setFreeFont(FSSB9);
  if (language == English) {
    tft.drawString(english[10], 127, 13);
  } else if (language == Turkish) {
    tft.drawString(turkish[10], 127, 13);
  }
  tft.pushImage(85, 7, 27, 26, Information_icon);
}

void serial_no_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 37, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 37, 300, 37, TFT_SHADOW);
  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  draw_greather_than(268, 48, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[29], 45, 46);
  } else if (language == Turkish) {
    tft.drawString(turkish[29], 45, 46);
  }
}

void product_date_bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 70, 280, 34, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 70, 300, 70, TFT_SHADOW);
  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  draw_greather_than(268, 81, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[30], 45, 79);
  } else if (language == Turkish) {
    tft.drawString(turkish[30], 45, 79);
  }
}

void information__bar(bool light) {

  if (light) {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_WHITE);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_WHITE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
  } else {
    tft.fillRoundRect(20, 103, 280, 34, 15, TFT_SHADOW);
    tft.fillRoundRect(20, 103, 280, 15, 0, TFT_SHADOW);
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);
  }

  tft.drawLine(75, 103, 300, 103, TFT_SHADOW);
  draw_greather_than(268, 114, TFT_SILVER);
  tft.setFreeFont(FSS9);
  if (language == English) {
    tft.drawString(english[31], 45, 112);
  } else if (language == Turkish) {
    tft.drawString(turkish[31], 45, 112);
  }
}


/*******************************************************************************************************************************************/


/*******************************************************************************************************************************************/
// MODBUS PİN KONTROL FONKSİYONLARI
void preTransmission() {
  digitalWrite(DE_RE_PIN_2, HIGH);
}

void postTransmission() {
  digitalWrite(DE_RE_PIN_2, LOW);
}

// WI-FI FIRMWARE GÜNCELLEME
void firmwareUpdate() {
  HTTPClient http;

  http.begin(firmwareUrl);  // URL of the firmware on GitHub
  int httpCode = http.GET();

  if (httpCode == HTTP_CODE_OK) {
    int fileSize = http.getSize();
    if (fileSize > 0) {
      bool canBegin = Update.begin(fileSize);
      if (canBegin) {
        WiFiClient *stream = http.getStreamPtr();
        size_t written = Update.writeStream(*stream);

        if (written == fileSize) {
          if (language == English) {
            tft.drawString("Download complete", 40, 112);
          } else if (language == Turkish) {
            tft.drawString("indirme eksiksiz tamamlandi", 40, 112);
            // tft.drawString("Pobieranie zakonczono", 40, 112);
          }
        } else {
          if (language == English) {
            tft.drawString("Downloaded data is missing", 40, 112);
            tft.drawString("Size: " + String(written) + " / " + String(fileSize), 40, 136);
            tft.drawString("The update has been canceled !", 40, 160);
          } else if (language == Turkish) {
            tft.drawString("indirilen veri eksik", 40, 112);
            tft.drawString("Boyut: " + String(written) + " / " + String(fileSize), 40, 136);
            tft.drawString("Guncelleme iptal edildi !", 40, 160);
            // tft.drawString("Brak pobranych danych", 40, 112);
            // tft.drawString("Rozmiar: " + String(written) + " / " + String(fileSize), 40, 136);
            // tft.drawString("Anulowano aktualizacje !", 40, 160);
          }
          Update.abort();  // Eksik yükleme durumunda işlemi iptal et
          return;          // İşlemi sonlandır
        }

        if (Update.end()) {
          if (Update.isFinished()) {
            if (language == English) {
              tft.drawString("Update complete.", 40, 136);
              tft.drawString("Rebooting the device ...", 40, 160);
            } else if (language == Turkish) {
              tft.drawString("Guncelleme tamamlandi.", 40, 136);
              tft.drawString("Cihaz yeniden baslatiliyor ...", 40, 160);
              // tft.drawString("Aktualizacja zakonczona", 40, 136);
              // tft.drawString("Uruchom ponownie ...", 40, 160);
            }
            delay(6000);
            ESP.restart();
          } else {
            if (language == English) {
              tft.drawString("Error update incomplete !", 40, 136);
            } else if (language == Turkish) {
              tft.drawString("Hata güncelleme tamamlanmadi !", 40, 136);
              // tft.drawString("Niekompletny blad aktualizacji !", 40, 136);
            }
          }
        } else {
          if (language == English) {
            tft.drawString("Error occurred Error #: " + String(Update.getError()), 40, 136);
          } else if (language == Turkish) {
            tft.drawString("Hata oluştu. Hata #: " + String(Update.getError()), 40, 136);
            // tft.drawString("Wystapil blad #. blad #: " + String(Update.getError()), 40, 136);
          }
        }
      } else {
        if (language == English) {
          tft.drawString("There's not enough space for OTA.", 40, 112);
        } else if (language == Turkish) {
          tft.drawString("OTA icin yeterli alan yok.", 40, 112);
          // tft.drawString("Brak wystarczajacej ilosci miejsca dla OTA", 40, 112);
        }
      }
    }
  } else {
    if (language == English) {
      tft.drawString("HTTP GET operation failed", 40, 112);
      tft.drawString("Error: " + String(http.errorToString(httpCode).c_str()), 40, 136);
    } else if (language == Turkish) {
      tft.drawString("HTTP GET islemi basarisiz oldu", 40, 112);
      tft.drawString("Hata: " + String(http.errorToString(httpCode).c_str()), 40, 136);
      // tft.drawString("Operacja pobierania HTTP nie powiodla sie", 40, 112);
      // tft.drawString("Blad: " + String(http.errorToString(httpCode).c_str()), 40, 136);
    }
  }
  http.end();
}

/*******************************************************************************************************************************************/

/**
 * @brief Bu fonksiyonlar, ekranda başlık dahil 1 - 6 adet arasında bar oluşturmak ve yön tuşlarına basarak bu barlar arasında gölge efekti ile gezinmeyi sağlar.
 *
 * @param icon_title Başlık barında görünecek küçük ikon
 * @param title_number Başlık barında görünecek yazının buffer numarası
 * @param text_position_x Yazıların x ekseninde başlangıç pozisyonu
 * @param text_aligned Bar stili
 *        - left_aligned : Alt seçeneği olan barlar 
 *        - middle_aligned : Alt seçeneği olmayan doğrudan seçenek olarak kullanılan barlar (yeşil tikli)
 * @param bar_1 1. sıradaki barın yazısının buffer numarası
 * @param bar_2 2. sıradaki barın yazısının buffer numarası
 * @param bar_3 3. sıradaki barın yazısının buffer numarası
 * @param bar_4 4. sıradaki barın yazısının buffer numarası
 * @param bar_5 5. sıradaki barın yazısının buffer numarası
 * @param bar_6 6. sıradaki barın yazısının buffer numarası
 * @param cursor_beginning Barlara karşılık gelen sıralı etiketin başlangıç ismi
 * @param cursor_finish Barlara karşılık gelen sıralı etiketin bitiş ismi
 *
 * @example 
 * bar_select(basic_settings_icon, english[32], 100, middle_aligned, units[4], units[5], units[6], units[7], units[8], units[9], m3_s, L_h);
 * Sondaki iki parametre ardışık sayılı tam sayı değişkenleri olmalı
 */

void bar_select(const uint16_t *icon_title, uint16_t title_number, uint16_t text_position_x, bool text_aligned, uint16_t bar_1, uint16_t bar_2, uint16_t bar_3, uint16_t bar_4, uint16_t bar_5, uint16_t bar_6, int cursor_beginning, int cursor_finish) {

  static int16_t buffer_value;
  static uint8_t current_cursor, current_previous_cursor;  // 1 ile 6 arasında birsayı

  if (opening_page == true) {
    opening_page = false;

    // Baştaki bardan başlaması için
    cursor = cursor_beginning;
    previous_cursor = cursor_beginning + 1;

    buffer_value = cursor_beginning - 1;  // bar seçimi yaparken cursor 1 sabit den başlamak için union değerini hafızada tutuyor

    tft.fillScreen(0xc658);  // arka planı hafif griye boya

    tft.fillRoundRect(20, 4, 280, 232, 15, TFT_WHITE);  // yumuşak köşeli beyaz zemin hazırla

    uint8_t title_char_counter;
    if (language == English) {
      title_char_counter = strlen(english[title_number]);
    } else if (language == Turkish) {
      title_char_counter = strlen(turkish[title_number]);
    }
    uint8_t title_text_beginning_point = 185 - (title_char_counter * 5);
    uint8_t title_icon_beginning_point = title_text_beginning_point - 35;

    tft.pushImage(title_icon_beginning_point, 7, 27, 26, icon_title);  // ikonu bas

    tft.setFreeFont(FSSB9);                  // başlık fontunu ayarla (kalın yap)
    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    if (language == English) {
      tft.drawString(english[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    } else if (language == Turkish) {
      tft.drawString(turkish[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    }

    // çizgileri ve büyüktür işaretini bastır
    for (int i = 1; i <= 6; i++) {
      if (text_aligned == left_aligned) {
        tft.drawLine(text_position_x, i * 33 + 4, 300, i * 33 + 4, TFT_SHADOW);
        draw_greather_than(268, i * 33 + 15, TFT_SILVER);
      } else {
        tft.drawLine(75, i * 33 + 4, 243, i * 33 + 4, TFT_SHADOW);
      }
    }

    tft.setFreeFont(FSS9);                    // yazı fontu
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi gölge zemin üstüne siyah yazı

    if (language == English) {
      // diğer barlardaki yazıları yazdır
      tft.drawString(english[bar_1], text_position_x, 46);
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(english[bar_2], text_position_x, 79);
      tft.drawString(english[bar_3], text_position_x, 112);
      tft.drawString(english[bar_4], text_position_x, 145);
      tft.drawString(english[bar_5], text_position_x, 178);
      tft.drawString(english[bar_6], text_position_x, 211);
    } else if (language == Turkish) {
      tft.drawString(turkish[bar_1], text_position_x, 46);
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(turkish[bar_2], text_position_x, 79);
      tft.drawString(turkish[bar_3], text_position_x, 112);
      tft.drawString(turkish[bar_4], text_position_x, 145);
      tft.drawString(turkish[bar_5], text_position_x, 178);
      tft.drawString(turkish[bar_6], text_position_x, 211);
    }
  }

  if (cursor > cursor_finish) cursor = cursor_beginning;  // kursoru baştaysa sona döndür
  if (cursor < cursor_beginning) cursor = cursor_finish;  // kursoru sondaysa başa döndür

  current_cursor = cursor - buffer_value;
  current_previous_cursor = previous_cursor - buffer_value;

  if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
    // Barlar arası gezinirken gölge animasyonları
    if (current_previous_cursor == ((cursor_finish - cursor_beginning) + 1)) {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 15, TFT_WHITE);
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 15, 0, TFT_WHITE);
    } else {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 0, TFT_WHITE);
    }

    if (current_cursor == (cursor_finish - cursor_beginning) + 1) {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 15, TFT_SHADOW);
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 15, 0, TFT_SHADOW);
    } else {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 0, TFT_SHADOW);
    }

    if (text_aligned == left_aligned) {  // Bar stili, alt seçeneği olan bar
      tft.drawLine(text_position_x, current_previous_cursor * 33 + 4, 300, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(text_position_x, current_previous_cursor * 33 + 37, 300, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
      draw_greather_than(268, current_previous_cursor * 33 + 15, TFT_SILVER);
      draw_greather_than(268, current_cursor * 33 + 15, TFT_SILVER);
    } else {  // alt seçeneği olmayan bar
      tft.drawLine(75, current_previous_cursor * 33 + 4, 243, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(75, current_previous_cursor * 33 + 37, 243, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
    }

    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_cursor) {
      case 1:
        if (language == English) {
          tft.drawString(english[bar_1], text_position_x, 46);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_1], text_position_x, 46);
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;

      case 3:
        if (language == English) {
          tft.drawString(english[bar_3], text_position_x, 112);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_3], text_position_x, 112);
        }
        break;

      case 4:
        if (language == English) {
          tft.drawString(english[bar_4], text_position_x, 145);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_4], text_position_x, 145);
        }
        break;

      case 5:
        if (language == English) {
          tft.drawString(english[bar_5], text_position_x, 178);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_5], text_position_x, 178);
        }
        break;

      case 6:
        if (language == English) {
          tft.drawString(english[bar_6], text_position_x, 211);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_6], text_position_x, 211);
        }

        break;
    }

    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_previous_cursor) {
      case 1:
        if (language == English) {
          tft.drawString(english[bar_1], text_position_x, 46);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_1], text_position_x, 46);
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;

      case 3:
        if (language == English) {
          tft.drawString(english[bar_3], text_position_x, 112);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_3], text_position_x, 112);
        }
        break;

      case 4:
        if (language == English) {
          tft.drawString(english[bar_4], text_position_x, 145);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_4], text_position_x, 145);
        }
        break;

      case 5:
        if (language == English) {
          tft.drawString(english[bar_5], text_position_x, 178);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_5], text_position_x, 178);
        }
        break;

      case 6:
        if (language == English) {
          tft.drawString(english[bar_6], text_position_x, 211);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_6], text_position_x, 211);
        }
    }

    if (text_aligned == middle_aligned) {
      write_tick(text_position_x - 35);
    }

    previous_cursor = cursor;
  }

  if ((text_aligned == middle_aligned) && (previous_tick_location != tick_location)) {
    delete_tick(text_position_x - 35);
    write_tick(text_position_x - 35);
    previous_tick_location = tick_location;
  }
}

void bar_select(const uint16_t *icon_title, uint16_t title_number, uint16_t text_position_x, bool text_aligned, uint16_t bar_1, uint16_t bar_2, uint16_t bar_3, uint16_t bar_4, uint16_t bar_5, int cursor_beginning, int cursor_finish) {

  static int16_t buffer_value;
  static uint8_t current_cursor, current_previous_cursor;  // 1 ile 6 arasında birsayı

  if (opening_page == true) {
    opening_page = false;

    // Baştaki bardan başlaması için
    cursor = cursor_beginning;
    previous_cursor = cursor_beginning + 1;

    buffer_value = cursor_beginning - 1;  // bar seçimi yaparken cursor 1 sabit den başlamak için union değerini hafızada tutuyor

    tft.fillScreen(0xc658);  // arka planı hafif griye boya

    tft.fillRoundRect(20, 4, 280, 199, 15, TFT_WHITE);  // yumuşak köşeli beyaz zemin hazırla

    uint8_t title_char_counter;
    if (language == English) {
      title_char_counter = strlen(english[title_number]);
    } else if (language == Turkish) {
      title_char_counter = strlen(turkish[title_number]);
    }
    uint8_t title_text_beginning_point = 185 - (title_char_counter * 5);
    uint8_t title_icon_beginning_point = title_text_beginning_point - 35;

    tft.pushImage(title_icon_beginning_point, 7, 27, 26, icon_title);  // ikonu bas

    tft.setFreeFont(FSSB9);                  // başlık fontunu ayarla (kalın yap)
    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    if (language == English) {
      tft.drawString(english[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    } else if (language == Turkish) {
      tft.drawString(turkish[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    }

    // çizgileri ve büyüktür işaretini bastır
    for (int i = 1; i <= 5; i++) {
      if (text_aligned == left_aligned) {
        tft.drawLine(text_position_x, i * 33 + 4, 300, i * 33 + 4, TFT_SHADOW);
        draw_greather_than(268, i * 33 + 15, TFT_SILVER);
      } else {
        tft.drawLine(75, i * 33 + 4, 243, i * 33 + 4, TFT_SHADOW);
      }
    }

    // diğer barlardaki yazıları yazdır
    tft.setFreeFont(FSS9);                    // yazı fontu
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi gölge zemin üstüne siyah yazı
    if (language == English) {
      // diğer barlardaki yazıları yazdır
      tft.drawString(english[bar_1], text_position_x, 46);
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(english[bar_2], text_position_x, 79);
      tft.drawString(english[bar_3], text_position_x, 112);
      tft.drawString(english[bar_4], text_position_x, 145);
      tft.drawString(english[bar_5], text_position_x, 178);
    } else if (language == Turkish) {
      tft.drawString(turkish[bar_1], text_position_x, 46);
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(turkish[bar_2], text_position_x, 79);
      tft.drawString(turkish[bar_3], text_position_x, 112);
      tft.drawString(turkish[bar_4], text_position_x, 145);
      tft.drawString(turkish[bar_5], text_position_x, 178);
    }
  }

  if (cursor > cursor_finish) cursor = cursor_beginning;  // kursoru baştaysa sona döndür
  if (cursor < cursor_beginning) cursor = cursor_finish;  // kursoru sondaysa başa döndür,

  current_cursor = cursor - buffer_value;
  current_previous_cursor = previous_cursor - buffer_value;

  if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin

    // Barlar arası gezinirken gölge animasyonları
    if (current_previous_cursor == (cursor_finish - cursor_beginning) + 1) {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 15, TFT_WHITE);
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 15, 0, TFT_WHITE);
    } else {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 0, TFT_WHITE);
    }

    if (current_cursor == ((cursor_finish - cursor_beginning) + 1)) {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 15, TFT_SHADOW);
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 15, 0, TFT_SHADOW);
    } else {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 0, TFT_SHADOW);
    }

    if (text_aligned == left_aligned) {  // Bar stili, alt seçeneği olan bar
      tft.drawLine(text_position_x, current_previous_cursor * 33 + 4, 300, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(text_position_x, current_previous_cursor * 33 + 37, 300, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
      draw_greather_than(268, current_previous_cursor * 33 + 15, TFT_SILVER);
      draw_greather_than(268, current_cursor * 33 + 15, TFT_SILVER);
    } else {  // alt seçeneği olmayan bar
      tft.drawLine(75, current_previous_cursor * 33 + 4, 243, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(75, current_previous_cursor * 33 + 37, 243, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
    }

    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_cursor) {
      case 1:
        if (language == English) {
          tft.drawString(english[bar_1], text_position_x, 46);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_1], text_position_x, 46);
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;

      case 3:
        if (language == English) {
          tft.drawString(english[bar_3], text_position_x, 112);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_3], text_position_x, 112);
        }
        break;

      case 4:
        if (language == English) {
          tft.drawString(english[bar_4], text_position_x, 145);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_4], text_position_x, 145);
        }
        break;

      case 5:
        if (language == English) {
          tft.drawString(english[bar_5], text_position_x, 178);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_5], text_position_x, 178);
        }
        break;
    }

    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_previous_cursor) {
      case 1:
        if (language == English) {
          tft.drawString(english[bar_1], text_position_x, 46);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_1], text_position_x, 46);
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;

      case 3:
        if (language == English) {
          tft.drawString(english[bar_3], text_position_x, 112);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_3], text_position_x, 112);
        }
        break;

      case 4:
        if (language == English) {
          tft.drawString(english[bar_4], text_position_x, 145);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_4], text_position_x, 145);
        }
        break;

      case 5:
        if (language == English) {
          tft.drawString(english[bar_5], text_position_x, 178);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_5], text_position_x, 178);
        }
        break;
    }

    if (text_aligned == middle_aligned) {
      write_tick(text_position_x - 35);
    }

    previous_cursor = cursor;
  }

  if ((text_aligned == middle_aligned) && (previous_tick_location != tick_location)) {
    delete_tick(text_position_x - 35);
    write_tick(text_position_x - 35);
    previous_tick_location = tick_location;
  }
}

void bar_select(const uint16_t *icon_title, uint16_t title_number, uint16_t text_position_x, bool text_aligned, uint16_t bar_1, uint16_t bar_2, uint16_t bar_3, uint16_t bar_4, int cursor_beginning, int cursor_finish) {

  static int16_t buffer_value;
  static uint8_t current_cursor, current_previous_cursor;  // 1 ile 6 arasında birsayı

  if (opening_page == true) {
    opening_page = false;

    // Baştaki bardan başlaması için
    cursor = cursor_beginning;
    previous_cursor = cursor_beginning + 1;

    buffer_value = cursor_beginning - 1;  // bar seçimi yaparken cursor 1 sabit den başlamak için union değerini hafızada tutuyor

    tft.fillScreen(0xc658);  // arka planı hafif griye boya

    tft.fillRoundRect(20, 4, 280, 166, 15, TFT_WHITE);  // yumuşak köşeli beyaz zemin hazırla

    uint8_t title_char_counter;
    if (language == English) {
      title_char_counter = strlen(english[title_number]);
    } else if (language == Turkish) {
      title_char_counter = strlen(turkish[title_number]);
    }
    uint8_t title_text_beginning_point = 185 - (title_char_counter * 5);
    uint8_t title_icon_beginning_point = title_text_beginning_point - 35;

    tft.pushImage(title_icon_beginning_point, 7, 27, 26, icon_title);  // ikonu bas

    tft.setFreeFont(FSSB9);                  // başlık fontunu ayarla (kalın yap)
    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    if (language == English) {
      tft.drawString(english[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    } else if (language == Turkish) {
      tft.drawString(turkish[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    }

    // çizgileri ve büyüktür işaretini bastır
    for (int i = 1; i <= 4; i++) {
      if (text_aligned == left_aligned) {
        tft.drawLine(text_position_x, i * 33 + 4, 300, i * 33 + 4, TFT_SHADOW);
        draw_greather_than(268, i * 33 + 15, TFT_SILVER);
      } else {
        tft.drawLine(75, i * 33 + 4, 243, i * 33 + 4, TFT_SHADOW);
      }
    }

    // diğer barlardaki yazıları yazdır
    tft.setFreeFont(FSS9);                    // yazı fontu
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi gölge zemin üstüne siyah yazı
    if (language == English) {
      // diğer barlardaki yazıları yazdır
      if (bar_1 == 154) {        // quick setup ın kalın yazılması için
        tft.setFreeFont(FSSB9);  // yazı fontu
        tft.drawString(english[bar_1], text_position_x, 46);
        tft.setFreeFont(FSS9);  // yazı fontu
      } else {
        tft.drawString(english[bar_1], text_position_x, 46);
      }
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(english[bar_2], text_position_x, 79);
      tft.drawString(english[bar_3], text_position_x, 112);
      tft.drawString(english[bar_4], text_position_x, 145);
    } else if (language == Turkish) {
      if (bar_1 == 154) {        // hızlı kurulum un kalın yazılması için
        tft.setFreeFont(FSSB9);  // yazı fontu
        tft.drawString(turkish[bar_1], text_position_x, 46);
        tft.setFreeFont(FSS9);  // yazı fontu
      } else {
        tft.drawString(turkish[bar_1], text_position_x, 46);
      }
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(turkish[bar_2], text_position_x, 79);
      tft.drawString(turkish[bar_3], text_position_x, 112);
      tft.drawString(turkish[bar_4], text_position_x, 145);
    }
  }

  if (cursor > cursor_finish) cursor = cursor_beginning;  // kursoru baştaysa sona döndür
  if (cursor < cursor_beginning) cursor = cursor_finish;  // kursoru sondaysa başa döndür,

  current_cursor = cursor - buffer_value;
  current_previous_cursor = previous_cursor - buffer_value;

  if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin

    // Barlar arası gezinirken gölge animasyonları
    if (current_previous_cursor == (cursor_finish - cursor_beginning) + 1) {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 15, TFT_WHITE);
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 15, 0, TFT_WHITE);
    } else {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 0, TFT_WHITE);
    }

    if (current_cursor == ((cursor_finish - cursor_beginning) + 1)) {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 15, TFT_SHADOW);
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 15, 0, TFT_SHADOW);
    } else {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 0, TFT_SHADOW);
    }

    // Bar stili, alt seçeneği olan bar
    if (text_aligned == left_aligned) {
      tft.drawLine(text_position_x, current_previous_cursor * 33 + 4, 300, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(text_position_x, current_previous_cursor * 33 + 37, 300, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
      draw_greather_than(268, current_previous_cursor * 33 + 15, TFT_SILVER);
      draw_greather_than(268, current_cursor * 33 + 15, TFT_SILVER);
    } else {  // alt seçeneği olmayan bar
      tft.drawLine(75, current_previous_cursor * 33 + 4, 243, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(75, current_previous_cursor * 33 + 37, 243, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
    }

    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_cursor) {
      case 1:
        if (language == English) {
          if (bar_1 == 154) {        // quick setup ın kalın yazılması için
            tft.setFreeFont(FSSB9);  // yazı fontu
            tft.drawString(english[bar_1], text_position_x, 46);
            tft.setFreeFont(FSS9);  // yazı fontu
          } else {
            tft.drawString(english[bar_1], text_position_x, 46);
          }
        } else if (language == Turkish) {
          if (bar_1 == 154) {        // hızlı kurulum un kalın yazılması için
            tft.setFreeFont(FSSB9);  // yazı fontu
            tft.drawString(turkish[bar_1], text_position_x, 46);
            tft.setFreeFont(FSS9);  // yazı fontu
          } else {
            tft.drawString(turkish[bar_1], text_position_x, 46);
          }
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;

      case 3:
        if (language == English) {
          tft.drawString(english[bar_3], text_position_x, 112);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_3], text_position_x, 112);
        }
        break;

      case 4:
        if (language == English) {
          tft.drawString(english[bar_4], text_position_x, 145);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_4], text_position_x, 145);
        }
        break;
    }

    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_previous_cursor) {
      case 1:
        if (language == English) {
          if (bar_1 == 154) {        // quick setup ın kalın yazılması için
            tft.setFreeFont(FSSB9);  // yazı fontu
            tft.drawString(english[bar_1], text_position_x, 46);
            tft.setFreeFont(FSS9);  // yazı fontu
          } else {
            tft.drawString(english[bar_1], text_position_x, 46);
          }
        } else if (language == Turkish) {
          if (bar_1 == 154) {        // hızlı kurulum un kalın yazılması için
            tft.setFreeFont(FSSB9);  // yazı fontu
            tft.drawString(turkish[bar_1], text_position_x, 46);
            tft.setFreeFont(FSS9);  // yazı fontu
          } else {
            tft.drawString(turkish[bar_1], text_position_x, 46);
          }
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;

      case 3:
        if (language == English) {
          tft.drawString(english[bar_3], text_position_x, 112);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_3], text_position_x, 112);
        }
        break;

      case 4:
        if (language == English) {
          tft.drawString(english[bar_4], text_position_x, 145);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_4], text_position_x, 145);
        }
        break;
    }

    if (text_aligned == middle_aligned) {
      write_tick(text_position_x - 35);
    }

    previous_cursor = cursor;
  }

  if ((text_aligned == middle_aligned) && (previous_tick_location != tick_location)) {
    delete_tick(text_position_x - 35);
    write_tick(text_position_x - 35);
    previous_tick_location = tick_location;
  }
}

void bar_select(const uint16_t *icon_title, uint16_t title_number, uint16_t text_position_x, bool text_aligned, uint16_t bar_1, uint16_t bar_2, uint16_t bar_3, int cursor_beginning, int cursor_finish) {

  static int16_t buffer_value;
  static uint8_t current_cursor, current_previous_cursor;  // 1 ile 6 arasında birsayı

  if (opening_page == true) {
    opening_page = false;

    // Baştaki bardan başlaması için
    cursor = cursor_beginning;
    previous_cursor = cursor_beginning + 1;

    buffer_value = cursor_beginning - 1;  // bar seçimi yaparken cursor 1 sabit den başlamak için union değerini hafızada tutuyor

    tft.fillScreen(0xc658);  // arka planı hafif griye boya

    tft.fillRoundRect(20, 4, 280, 133, 15, TFT_WHITE);  // yumuşak köşeli beyaz zemin hazırla

    uint8_t title_char_counter;
    if (language == English) {
      title_char_counter = strlen(english[title_number]);
    } else if (language == Turkish) {
      title_char_counter = strlen(turkish[title_number]);
    }
    uint8_t title_text_beginning_point = 185 - (title_char_counter * 5);
    uint8_t title_icon_beginning_point = title_text_beginning_point - 35;

    tft.pushImage(title_icon_beginning_point, 7, 27, 26, icon_title);  // ikonu bas

    tft.setFreeFont(FSSB9);                  // başlık fontunu ayarla (kalın yap)
    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    if (language == English) {
      tft.drawString(english[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    } else if (language == Turkish) {
      tft.drawString(turkish[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    }


    // çizgileri ve büyüktür işaretini bastır
    for (int i = 1; i <= 3; i++) {
      if (text_aligned == left_aligned) {
        tft.drawLine(text_position_x, i * 33 + 4, 300, i * 33 + 4, TFT_SHADOW);
        draw_greather_than(268, i * 33 + 15, TFT_SILVER);
      } else {
        tft.drawLine(75, i * 33 + 4, 243, i * 33 + 4, TFT_SHADOW);
      }
    }

    // diğer barlardaki yazıları yazdır
    tft.setFreeFont(FSS9);                    // yazı fontu
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi gölge zemin üstüne siyah yazı
    if (language == English) {
      // diğer barlardaki yazıları yazdır
      tft.drawString(english[bar_1], text_position_x, 46);
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(english[bar_2], text_position_x, 79);
      tft.drawString(english[bar_3], text_position_x, 112);
    } else if (language == Turkish) {
      tft.drawString(turkish[bar_1], text_position_x, 46);
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(turkish[bar_2], text_position_x, 79);
      tft.drawString(turkish[bar_3], text_position_x, 112);
    }
  }

  if (cursor > cursor_finish) cursor = cursor_beginning;  // kursoru baştaysa sona döndür
  if (cursor < cursor_beginning) cursor = cursor_finish;  // kursoru sondaysa başa döndür,

  current_cursor = cursor - buffer_value;
  current_previous_cursor = previous_cursor - buffer_value;

  if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin

    // Barlar arası gezinirken gölge animasyonları
    if (current_previous_cursor == (cursor_finish - cursor_beginning) + 1) {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 15, TFT_WHITE);
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 15, 0, TFT_WHITE);
    } else {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 0, TFT_WHITE);
    }

    if (current_cursor == ((cursor_finish - cursor_beginning) + 1)) {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 15, TFT_SHADOW);
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 15, 0, TFT_SHADOW);
    } else {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 0, TFT_SHADOW);
    }

    // Bar stili, alt seçeneği olan bar
    if (text_aligned == left_aligned) {
      tft.drawLine(text_position_x, current_previous_cursor * 33 + 4, 300, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(text_position_x, current_previous_cursor * 33 + 37, 300, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
      draw_greather_than(268, current_previous_cursor * 33 + 15, TFT_SILVER);
      draw_greather_than(268, current_cursor * 33 + 15, TFT_SILVER);
    } else {  // alt seçeneği olmayan bar
      tft.drawLine(75, current_previous_cursor * 33 + 4, 243, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(75, current_previous_cursor * 33 + 37, 243, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
    }

    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_cursor) {
      case 1:
        if (language == English) {
          tft.drawString(english[bar_1], text_position_x, 46);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_1], text_position_x, 46);
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;

      case 3:
        if (language == English) {
          tft.drawString(english[bar_3], text_position_x, 112);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_3], text_position_x, 112);
        }
        break;
    }

    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_previous_cursor) {
      case 1:
        if (language == English) {
          tft.drawString(english[bar_1], text_position_x, 46);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_1], text_position_x, 46);
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;

      case 3:
        if (language == English) {
          tft.drawString(english[bar_3], text_position_x, 112);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_3], text_position_x, 112);
        }
        break;
    }

    if (text_aligned == middle_aligned) {
      write_tick(text_position_x - 35);
    }

    previous_cursor = cursor;
  }

  if ((text_aligned == middle_aligned) && (previous_tick_location != tick_location)) {
    delete_tick(text_position_x - 35);
    write_tick(text_position_x - 35);
    previous_tick_location = tick_location;
  }
}

void bar_select(const uint16_t *icon_title, uint16_t title_number, uint16_t text_position_x, bool text_aligned, uint16_t bar_1, uint16_t bar_2, int cursor_beginning, int cursor_finish) {

  static int16_t buffer_value;
  static uint8_t current_cursor, current_previous_cursor;  // 1 ile 6 arasında birsayı

  if (opening_page == true) {
    opening_page = false;

    // Baştaki bardan başlaması için
    cursor = cursor_beginning;
    previous_cursor = cursor_beginning + 1;

    buffer_value = cursor_beginning - 1;  // bar seçimi yaparken cursor 1 sabit den başlamak için union değerini hafızada tutuyor

    tft.fillScreen(0xc658);  // arka planı hafif griye boya

    tft.fillRoundRect(20, 4, 280, 100, 15, TFT_WHITE);  // yumuşak köşeli beyaz zemin hazırla

    uint8_t title_char_counter;
    if (language == English) {
      title_char_counter = strlen(english[title_number]);
    } else if (language == Turkish) {
      title_char_counter = strlen(turkish[title_number]);
    }
    uint8_t title_text_beginning_point = 185 - (title_char_counter * 5);
    uint8_t title_icon_beginning_point = title_text_beginning_point - 35;

    tft.pushImage(title_icon_beginning_point, 7, 27, 26, icon_title);  // ikonu bas

    tft.setFreeFont(FSSB9);                  // başlık fontunu ayarla (kalın yap)
    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    if (language == English) {
      tft.drawString(english[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    } else if (language == Turkish) {
      tft.drawString(turkish[title_number], title_text_beginning_point, 13);  // başlık yazısını yazdır
    }

    // çizgileri ve büyüktür işaretini bastır
    for (int i = 1; i <= 2; i++) {
      if (text_aligned == left_aligned) {
        tft.drawLine(text_position_x, i * 33 + 4, 300, i * 33 + 4, TFT_SHADOW);
        draw_greather_than(268, i * 33 + 15, TFT_SILVER);
      } else {
        tft.drawLine(75, i * 33 + 4, 243, i * 33 + 4, TFT_SHADOW);
      }
    }

    // diğer barlardaki yazıları yazdır
    tft.setFreeFont(FSS9);                    // yazı fontu
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi gölge zemin üstüne siyah yazı
    if (language == English) {
      // diğer barlardaki yazıları yazdır
      tft.drawString(english[bar_1], text_position_x, 46);
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(english[bar_2], text_position_x, 79);
    } else if (language == Turkish) {
      tft.drawString(turkish[bar_1], text_position_x, 46);
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
      tft.drawString(turkish[bar_2], text_position_x, 79);
    }
  }

  if (cursor > cursor_finish) cursor = cursor_beginning;  // kursoru baştaysa sona döndür
  if (cursor < cursor_beginning) cursor = cursor_finish;  // kursoru sondaysa başa döndür,

  current_cursor = cursor - buffer_value;
  current_previous_cursor = previous_cursor - buffer_value;

  if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin

    // Barlar arası gezinirken gölge animasyonları
    if (current_previous_cursor == (cursor_finish - cursor_beginning) + 1) {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 15, TFT_WHITE);
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 15, 0, TFT_WHITE);
    } else {
      tft.fillRoundRect(20, current_previous_cursor * 33 + 4, 280, 34, 0, TFT_WHITE);
    }

    if (current_cursor == ((cursor_finish - cursor_beginning) + 1)) {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 15, TFT_SHADOW);
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 15, 0, TFT_SHADOW);
    } else {
      tft.fillRoundRect(20, current_cursor * 33 + 4, 280, 34, 0, TFT_SHADOW);
    }

    // Bar stili, alt seçeneği olan bar
    if (text_aligned == left_aligned) {
      tft.drawLine(text_position_x, current_previous_cursor * 33 + 4, 300, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(text_position_x, current_previous_cursor * 33 + 37, 300, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
      draw_greather_than(268, current_previous_cursor * 33 + 15, TFT_SILVER);
      draw_greather_than(268, current_cursor * 33 + 15, TFT_SILVER);
    } else {  // alt seçeneği olmayan bar
      tft.drawLine(75, current_previous_cursor * 33 + 4, 243, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(75, current_previous_cursor * 33 + 37, 243, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
    }

    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_cursor) {
      case 1:
        if (language == English) {
          tft.drawString(english[bar_1], text_position_x, 46);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_1], text_position_x, 46);
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;
    }

    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_previous_cursor) {
      case 1:
        if (language == English) {
          tft.drawString(english[bar_1], text_position_x, 46);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_1], text_position_x, 46);
        }
        break;

      case 2:
        if (language == English) {
          tft.drawString(english[bar_2], text_position_x, 79);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 79);
        }
        break;
    }

    if (text_aligned == middle_aligned) {
      write_tick(text_position_x - 35);
    }

    previous_cursor = cursor;
  }

  if ((text_aligned == middle_aligned) && (previous_tick_location != tick_location)) {
    delete_tick(text_position_x - 35);
    write_tick(text_position_x - 35);
    previous_tick_location = tick_location;
  }
}

void bar_select(const uint16_t *icons[], uint16_t text_position_x, bool text_aligned, uint16_t bar_1, uint16_t bar_2, uint16_t bar_3, uint16_t bar_4, uint16_t bar_5, uint16_t bar_6, uint16_t bar_7, int cursor_beginning, int cursor_finish) {


  static int16_t buffer_value;
  static uint8_t current_cursor, current_previous_cursor;  // 1 ile 6 arasında birsayı

  if (opening_page == true) {
    opening_page = false;

    // Baştaki bardan başlaması için
    cursor = cursor_beginning;
    previous_cursor = cursor_beginning + 1;

    buffer_value = cursor_beginning - 1;  // bar seçimi yaparken cursor 1 sabit den başlamak için union değerini hafızada tutuyor

    tft.fillScreen(0xc658);  // arka planı hafif griye boya

    tft.fillRoundRect(20, 4, 280, 232, 15, TFT_WHITE);  // yumuşak köşeli beyaz zemin hazırla

    // çizgileri ve büyüktür işaretini bastır
    for (int i = 0; i <= 6; i++) {
      if (text_aligned == left_aligned) {
        if (i > 0) { tft.drawLine(text_position_x, i * 33 + 4, 300, i * 33 + 4, TFT_SHADOW); }
        draw_greather_than(268, i * 33 + 15, TFT_SILVER);
      } else {
        if (i > 0) { tft.drawLine(75, i * 33 + 4, 243, i * 33 + 4, TFT_SHADOW); }
      }
    }

    tft.setFreeFont(FSS9);                    // yazı fontu
    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi gölge zemin üstüne siyah yazı

    if (language == English) {
      // diğer barlardaki yazıları yazdır
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı


      tft.drawString(english[bar_1], text_position_x, 13);
      tft.pushImage(33, 7, 27, 26, icons[0]);

      tft.drawString(english[bar_2], text_position_x, 46);
      tft.pushImage(33, 40, 27, 26, icons[1]);
      tft.drawString(english[bar_3], text_position_x, 79);
      tft.pushImage(33, 73, 27, 26, icons[2]);

      tft.drawString(english[bar_4], text_position_x, 112);
      tft.pushImage(33, 106, 27, 26, icons[3]);

      tft.drawString(english[bar_5], text_position_x, 145);
      tft.pushImage(33, 139, 27, 26, icons[4]);

      tft.drawString(english[bar_6], text_position_x, 178);
      tft.pushImage(33, 172, 27, 26, icons[5]);

      tft.drawString(english[bar_7], text_position_x, 211);
      tft.pushImage(33, 205, 27, 26, icons[6]);

    } else if (language == Turkish) {
      tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı

      tft.drawString(turkish[bar_1], text_position_x, 13);
      tft.pushImage(33, 7, 27, 26, icons[0]);

      tft.drawString(turkish[bar_2], text_position_x, 46);
      tft.pushImage(33, 40, 27, 26, icons[1]);
      tft.drawString(turkish[bar_3], text_position_x, 79);
      tft.pushImage(33, 73, 27, 26, icons[2]);

      tft.drawString(turkish[bar_4], text_position_x, 112);
      tft.pushImage(33, 106, 27, 26, icons[3]);

      tft.drawString(turkish[bar_5], text_position_x, 145);
      tft.pushImage(33, 139, 27, 26, icons[4]);

      tft.drawString(turkish[bar_6], text_position_x, 178);
      tft.pushImage(33, 172, 27, 26, icons[5]);

      tft.drawString(turkish[bar_7], text_position_x, 211);
      tft.pushImage(33, 205, 27, 26, icons[6]);
    }
  }

  if (cursor > cursor_finish) cursor = cursor_beginning;  // kursoru baştaysa sona döndür
  if (cursor < cursor_beginning) cursor = cursor_finish;  // kursoru sondaysa başa döndür

  current_cursor = cursor - buffer_value;
  current_previous_cursor = previous_cursor - buffer_value;
  if (cursor != previous_cursor) {  // cursor değiştiyse menü içi gezin
    // Önceki seçili barın gölgesini temizle
    if (current_previous_cursor <= (cursor_finish - cursor_beginning + 1)) {
      if (current_previous_cursor != 1 && current_previous_cursor != 7) {
        tft.fillRoundRect(20, (current_previous_cursor - 1) * 33 + 4, 280, 34, 0, TFT_WHITE);
      } else if (current_previous_cursor == 1) {
        tft.fillRoundRect(20, (current_previous_cursor - 1) * 33 + 4, 280, 34, 15, TFT_WHITE);
        tft.fillRect(20, (current_previous_cursor - 1) * 33 + 23, 280, 15, TFT_WHITE);
      } else if (current_previous_cursor == 7) {
        tft.fillRoundRect(20, (current_previous_cursor - 1) * 33 + 4, 280, 34, 15, TFT_WHITE);
        tft.fillRect(20, (current_previous_cursor - 1) * 33 + 4, 280, 15, TFT_WHITE);
      }
    }

    // Yeni seçili barın gölgesini çiz
    if (current_cursor <= (cursor_finish - cursor_beginning + 1)) {
      if (current_cursor != 1 && current_cursor != 7) {
        //tft.fillRoundRect(20, (current_cursor - 1) * 33 + 4, 280, 34, 0, TFT_SHADOW);
        tft.fillRect(20, (current_cursor - 1) * 33 + 4, 280, 34, TFT_SHADOW);
      } else if (current_cursor == 1) {
        tft.fillRoundRect(20, (current_cursor - 1) * 33 + 4, 280, 34, 15, TFT_SHADOW);
        tft.fillRect(20, (current_cursor - 1) * 33 + 23, 280, 15, TFT_SHADOW);
      } else if (current_cursor == 7) {
        tft.fillRoundRect(20, (current_cursor - 1) * 33 + 4, 280, 34, 15, TFT_SHADOW);
        tft.fillRect(20, (current_cursor - 1) * 33 + 4, 280, 15, TFT_SHADOW);
      }
    }


    // Sabit çizgileri ve büyüktür işaretlerini her seferinde yeniden çiz
    for (int i = 0; i <= 6; i++) {
      if (text_aligned == left_aligned) {
        if (i > 0) { tft.drawLine(text_position_x, i * 33 + 4, 300, i * 33 + 4, TFT_SHADOW); }
        draw_greather_than(268, i * 33 + 15, TFT_SILVER);
      } else {
        if (i > 0) { tft.drawLine(75, i * 33 + 4, 243, i * 33 + 4, TFT_SHADOW); }
      }
    }

    if (text_aligned == left_aligned) {  // Bar stili, alt seçeneği olan bar
      tft.drawLine(text_position_x, current_previous_cursor * 33 + 4, 300, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(text_position_x, current_previous_cursor * 33 + 37, 300, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
      draw_greather_than(268, current_previous_cursor * 33 + 15, TFT_SILVER);
      draw_greather_than(268, current_cursor * 33 + 15, TFT_SILVER);
    } else {  // alt seçeneği olmayan bar
      tft.drawLine(75, current_previous_cursor * 33 + 4, 243, current_previous_cursor * 33 + 4, TFT_SHADOW);
      if (previous_cursor != cursor_finish) {
        tft.drawLine(75, current_previous_cursor * 33 + 37, 243, current_previous_cursor * 33 + 37, TFT_SHADOW);
      }
    }



    tft.setTextColor(TFT_BLACK, TFT_SHADOW);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_cursor) {
      case 1:
        if (language == English) {

          tft.drawString(english[bar_1], text_position_x, 13);
          tft.pushImage(33, 7, 27, 26, icons[0]);
        } else if (language == Turkish) {

          tft.drawString(turkish[bar_1], text_position_x, 13);
          tft.pushImage(33, 7, 27, 26, icons[0]);
        }
        break;

      case 2:
        if (language == English) {

          tft.drawString(english[bar_2], text_position_x, 46);
          tft.pushImage(33, 40, 27, 26, icons[1]);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 46);
          tft.pushImage(33, 40, 27, 26, icons[1]);
        }
        break;

      case 3:
        if (language == English) {

          tft.drawString(english[bar_3], text_position_x, 79);
          tft.pushImage(33, 73, 27, 26, icons[2]);
        } else if (language == Turkish) {

          tft.drawString(turkish[bar_3], text_position_x, 79);
          tft.pushImage(33, 73, 27, 26, icons[2]);
        }
        break;

      case 4:
        if (language == English) {
          tft.drawString(english[bar_4], text_position_x, 112);
          tft.pushImage(33, 106, 27, 26, icons[3]);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_4], text_position_x, 112);
          tft.pushImage(33, 106, 27, 26, icons[3]);
        }
        break;

      case 5:
        if (language == English) {
          tft.drawString(english[bar_5], text_position_x, 145);
          tft.pushImage(33, 139, 27, 26, icons[4]);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_5], text_position_x, 145);
          tft.pushImage(33, 139, 27, 26, icons[4]);
        }
        break;

      case 6:
        if (language == English) {

          tft.drawString(english[bar_6], text_position_x, 178);
          tft.pushImage(33, 172, 27, 26, icons[5]);
        } else if (language == Turkish) {

          tft.drawString(turkish[bar_6], text_position_x, 178);
          tft.pushImage(33, 172, 27, 26, icons[5]);
        }

        break;
      case 7:
        if (language == English) {

          tft.drawString(english[bar_7], text_position_x, 211);
          tft.pushImage(33, 205, 27, 26, icons[6]);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_7], text_position_x, 211);
          tft.pushImage(33, 205, 27, 26, icons[6]);
        }

        break;
    }

    tft.setTextColor(TFT_BLACK, TFT_WHITE);  // yazı arka plan rengi beyaz  zemin üstüne siyah yazı
    switch (current_previous_cursor) {
      case 1:
        if (language == English) {

          tft.drawString(english[bar_1], text_position_x, 13);
          tft.pushImage(33, 7, 27, 26, icons[0]);
        } else if (language == Turkish) {

          tft.drawString(turkish[bar_1], text_position_x, 13);
          tft.pushImage(33, 7, 27, 26, icons[0]);
        }
        break;

      case 2:
        if (language == English) {

          tft.drawString(english[bar_2], text_position_x, 46);
          tft.pushImage(33, 40, 27, 26, icons[1]);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_2], text_position_x, 46);
          tft.pushImage(33, 40, 27, 26, icons[1]);
        }
        break;

      case 3:
        if (language == English) {

          tft.drawString(english[bar_3], text_position_x, 79);
          tft.pushImage(33, 73, 27, 26, icons[2]);
        } else if (language == Turkish) {

          tft.drawString(turkish[bar_3], text_position_x, 79);
          tft.pushImage(33, 73, 27, 26, icons[2]);
        }
        break;

      case 4:
        if (language == English) {
          tft.drawString(english[bar_4], text_position_x, 112);
          tft.pushImage(33, 106, 27, 26, icons[3]);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_4], text_position_x, 112);
          tft.pushImage(33, 106, 27, 26, icons[3]);
        }
        break;

      case 5:
        if (language == English) {
          tft.drawString(english[bar_5], text_position_x, 145);
          tft.pushImage(33, 139, 27, 26, icons[4]);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_5], text_position_x, 145);
          tft.pushImage(33, 139, 27, 26, icons[4]);
        }
        break;

      case 6:
        if (language == English) {

          tft.drawString(english[bar_6], text_position_x, 178);
          tft.pushImage(33, 172, 27, 26, icons[5]);
        } else if (language == Turkish) {

          tft.drawString(turkish[bar_6], text_position_x, 178);
          tft.pushImage(33, 172, 27, 26, icons[5]);
        }

        break;
      case 7:
        if (language == English) {

          tft.drawString(english[bar_7], text_position_x, 211);
          tft.pushImage(33, 205, 27, 26, icons[6]);
        } else if (language == Turkish) {
          tft.drawString(turkish[bar_7], text_position_x, 211);
          tft.pushImage(33, 205, 27, 26, icons[6]);
        }

        break;
    }


    if (text_aligned == middle_aligned) {
      write_tick(text_position_x - 35);
    }

    if (text_aligned == middle_aligned) {
      write_tick(text_position_x - 35);
    }

    previous_cursor = cursor;
  }

  // if ((text_aligned == middle_aligned) && (previous_tick_location != tick_location)) {
  //   delete_tick(text_position_x - 35);
  //   write_tick(text_position_x - 35);
  //   previous_tick_location = tick_location;
  // }
}
